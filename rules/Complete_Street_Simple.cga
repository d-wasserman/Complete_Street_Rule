/*
 * File:    Complete Street.cga
 * Created: 10/30/2015 Oct 2015
 * Last Updated: 10/1/2022
 * Author:  David J. Wasserman- As Part of and Based on Work from Esri Redlands
 * License: Apache 2.0 License and ESRI Attribution License.
 * Source: https://github.com/d-wasserman/Complete_Street_Rule
# ESRI Attribution License:
#	ESRI Derivative work
#	http://mappingcenter.esri.com/downloads/AttributionAndLicense_05_09_07.pdf
#
# Copyright 2020 David J. Wasserman
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required bys applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# --------------------------------
 */

# Differences to Street Construction Simple:
# This ruleset can also generate stop markings and crosswalks (by using the 
# objects attributes) and generates more detailed roundabouts
# Differences to Street Construction Standard:
# More informed by MUTCD/AASHTO/NACTO Street Guidelines, but used approximations. 
# Can create Bus lanes, bike lanes (of different colors), parking lanes (with parklets), 
# medians (with alternative planting configurations), boulevards(double medians), and even
# highways with HOV lanes, bridge supports, and shoulders (in center type and bicycle buffer).
#
#Sources for Reports and Descriptions:
#1.http://www.fhwa.dot.gov/publications/research/safety/09039/03.cfm
#2.http://mutcd.fhwa.dot.gov/index.htm
#3.http://www.qcode.us/codes/southpasadena/view.php?topic=36-3-36_310-36_310_080
#4.http://nacto.org/usdg/
#5.http://nacto.org/cities-for-cycling/design-guide/
#6.https://bookstore.transportation.org/collection_detail.aspx?ID=110
#7.http://transweb.sjsu.edu/project/1005.html
#8.http://onlinepubs.trb.org/onlinepubs/nchrp/nchrp_rpt_504.pdf 

#Useful Numbers: 
#13 feet	==3.9624 Meters
#12 feet	==3.6576 Meters	
#11 feet	==3.3528 Meters
#10 feet	==3.048  Meters
#9 feet		==2.7432 Meters
#8 feet		==2.1336 Meters
#7 feet		==1.8288 Meters
#6 feet		==1.524  Meters
#4 feet		==1.2192 Meters
#3 feet		==.9144  Meters
#2 feet		==.6096  Meters
#1 feet		==.3048  Meters
#1/2 feet	==.1524  Meters
#1 inch		==.0254  Meters
version "2022.0"



###################################################
# Control Attributes-INSPECTOR
#
@Group("DISPLAY OPTIONS",0) @Enum("true","false")@Order(1)@Description("When true, textures are on display, when false textures are removed. If true it deletes an unused UVset (see comments for details).")
attr Display_Textures = "true"
@Order(2) @Description("Visually colors the entire street model based on the attributes of a street. Usage thematic looks best when textures are turned off.")
@Enum("Thematics Off", "Solid Color", "Peak Runoff/Permeability","Bike Preference","Pedestrian Preference","Auto Preference","Transit Preference","All Mode Preference","Usage","Transit Highlight","Bicycle Highlight","Auto Highlight","Pedestrian Highlight","Planting Highlight","Shared Mobility Highlight","Semantic","Flood Scenario")
attr Display_Thematics = "Thematics Off" 
@Order(3) @Color @Description("When the Solid Color thematic is used for highlighting certain streets or mode classes, this chooses the color that is utilized by the thematic.") @Hidden
attr Solid_Color = "#FFFFFF"
@Order(4)@Color @Description("When a mode emphasis thematic is chosen, the color fo the other streets is chosen by default by this hidden parameter.")@Hidden
attr Secondary_Solid_Color= Brightness
@Enum("Best Fit","Exact","Flag") @Order(5)@Description("Determines whether the lane width will be the best of fit, exact width, or flag unallocated space red when it is 1/3 the current lane width (usually 3-4 feet).")
attr Space_Management= "Best Fit"
@Enum("Very High","High","Moderate","Low") @Order(6)@Description("This attribute controls the level of detail of the selected textures and OBJs. Typically a lower LOD will decrease the polygon count and texture image resolution.")
attr LOD_Setting	  ="Moderate"
@Range(min=0,max=1) @Order(7)@Description("This attribute controls the transparency of the street models created by the rule.")@Hidden
attr Transparency	  = 0
@Range(min=0,max=1) @Order(8) @Description("This attribute adjusts the global specularity of the street model.") @Hidden
attr Specularity	  = 1
@Enum("true","false") @Order(9)@Description("This attribute controls whether or not context aware queries can be used. Default is off when using low LODs.") @Hidden
attr Context_Aware_Queries = case Not_High_LOD : false else: true
@Enum("true","false") @Order(9)@Description("This attribute controls whether key reporting elements are enabled. Low LOD defaults to turning reports off.") @Hidden
attr Reporting_On = case LOD_Setting == "Low": "false" else: "true"

texturingOn = bool(Display_Textures) 	# Shorthand.
thematicsOn = Display_Thematics != "Thematics Off"
coloringOn = !thematicsOn && texturingOn	# Shorthand.
reportingOn = bool(Reporting_On)

const peakRunoffDisplayOn = Display_Thematics == "Peak Runoff/Permeability"
const Not_Low_LOD		  = case LOD_Setting!="Low": true else: false
const Not_High_LOD		  = case find(LOD_Setting,"High",0)==-1: true else: false
const Not_Very_High_LOD	  = case find(LOD_Setting,"Very High",0)==-1:true else: false
const LOD_Object_Choice   = case Not_Low_LOD:"High" else: "Low"

@Order(1)@Group("ROAD LAYOUT","Basic Components",1) @Range(min=0,max=1) @Description("Represents the fraction of the lanes allocated to the *Right Lanes*. If 1 or 0, they become 1 way streets.")
attr Lane_Distribution 			= _getInitialLaneDistribution
@Order(2) @Distance @Range(min=2.7,max=3.9624)@Description("Determines the widths of the main travel lanes. Typically, Freeways are about 12 feet (3.6 m), Arterials 11-12 feet (3.3-3.6 m), Collectors 10-12 feet (3.0-3.6 m), and Local roads 9-12 feet (2.7-3.6 m).")
attr Lane_Width					= (laneWidth - .2)
@Order(4) @Enum("right-hand","left-hand")@Description("Orients the road for right vs. left traffic. Please note that some aspects of the rule do not *flip* when this is changed such as the median.")
attr Traffic_Direction			= "right-hand"
@Order(5) @Range(min=0,max=80) @Description("A descriptive attribute that feeds into reporting. If >= 40 mph, Design Speed is calculated as Speed_Limit +7.5, if less than 40, design speed is assumed equal to the Speed_Limit (see comments for details). 1 MPH==1.6093 KPH.")
attr Speed_Limit_in_MPH			= _InititalSpeedLimit		

@Group("ROAD LAYOUT","Stop Markings",2)
@Order(1) @Enum("none","line only","with stop marking","arrows on all lanes","arrows on side lanes","arrows for right turn","arrows for left turn","right;right;none;none","right;stop;stop;left","right;all;through-left;left","right;through-right;none","right;both;left",restricted=false) @Description("The initial stop markings do not take into account the topology of the intersection i.e. they need to be set manually")
attr Stop_Begin 				= _getInitialStop(connectionStart,nLanesLeft+_Lt_Transit_Lane_Count)
@Order(2) @Enum("none","line only","with stop marking","arrows on all lanes","arrows on side lanes","arrows for right turn","arrows for left turn","right;right;none;none","right;stop;stop;left","right;all;through-left;left","right;through-right;none","right;both;left",restricted=false) @Description("The initial stop markings do not take into account the topology of the intersection i.e. they need to be set manually")
attr Stop_End 					= _getInitialStop(connectionEnd, _Distribute_Right_Lanes+_Rt_Transit_Lane_Count)

@Group("ROAD LAYOUT","Crosswalk Markings",3)
@Order(1) @Enum("none","continental","ladder","transverse","dashed","solid","custom","ladder custom","raised custom") @Description("NACTO-High­-visibility ladder, zebra, and continental crosswalk markings are preferable to standard parallel or dashed pavement markings. These are more visible to approaching vehicles and have been shown to improve yielding behavior.")										# TODO "solid","dashed","ladder"
attr Crosswalk_Begin 			= _getInitialCrosswalk(connectionStart)
@Order(2) @Enum("none","continental","ladder","transverse","dashed","solid","custom","ladder custom","raised custom")@Description("NACTO-High­-visibility ladder, zebra, and continental crosswalk markings are preferable to standard parallel or dashed pavement markings. These are more visible to approaching vehicles and have been shown to improve yielding behavior.")									
attr Crosswalk_End 				= _getInitialCrosswalk(connectionEnd)
@Order(3) @Distance @Range(min=0,max=20) @Description("Crosswalk to Stop Bar Distance. If the Crosswalk UV is clipping geometry, adjust this to set it back more on angled streets. If used, stop and yield lines should be placed a minimum of  4 ft (1.2 m) from the Crosswalk-MUTCD. NACTO suggests a minimum of 8 ft (2.44 m) in urban areas.")
attr Begin_Crosswalk_To_Stop_Bar= _getInitialGap(connectionStart)
@Order(4) @Distance @Range(min=0,max=20) @Description("Crosswalk to Stop Bar Distance. If the Crosswalk UV is clipping geometry, adjust this to set it back more on angled streets. If used, stop and yield lines should be placed a minimum of  4 ft (1.2 m) from the Crosswalk-MUTCD. NACTO suggests a minimum of 8 ft (2.44 m) in urban areas.")
attr End_Crosswalk_To_Stop_Bar 	= _getInitialGap(connectionEnd)
@Order(5) @Enum("white","yellow") @Description("Determines the color of painted crosswalks.")@Hidden
attr Crosswalk_Color 			= "white"
@Order(6) @File("tif","jpg","png","tiff","gif","jpeg","psp","jsl","sgi","tga","bmp","dds")@Description("Creates a 2 m by 2 m tile of the image selected on the crosswalk. Keep in mind that if another painted tile is chosen, the paint area will not appear in reporting. Defer to Crosswalk Area Reports.")
attr Custom_Crosswalk_Texture	= SidewalkFolder+"/Paver Brick Red Basket Weave.jpg"
@Order(7) @Distance @Range(min=0,max=10) @Description("This attribrute overrides the default Crosswalk Width. NACTO- Stripe the crosswalk as wide as or wider than the walkway it connects to.")
attr Crosswalk_Width			= _crosswalkWidth

@Group("ROAD LAYOUT","On-Street Parking",5)
@Order(1)@Enum("None","Parallel","Angled Nose In","Angled Back In", "Parallel with Curbside Passenger Loading", "Parallel with Curbside Freight Loading","Parallel with Curbside Carshare Parking","Parallel with Curbside Bus Stop","Parallel with Curbside DoBi & Scooter Parking") @Description("Will create parking of that type with default lengths and widths. Keep in mind, adjusting the length/width will make it lock onto that value. To reset it to automatic default, set the Attribute Connection Editor back to rule-defined value.")
attr Right_Parking_Type			= "None"
@Order(2) @Distance @Range(min=0,max=5)@Description("Good default is 8 feet (2.4384 m) with a minimum of 7 feet (2.1336 m) for low turn over locations for parallel parking. Angled parking varies on angle, but a 30-45 degree depth suggestion is 19 feet (5.7912 m). Design guidance on width varies with conditions. ")@Hidden
attr Right_Parking_Width		= _ParkingWidth(Right_Parking_Type) 
@Order(3)@Distance @Range(min=0,max=10)@Description("For Parallel Parking 6.1 to 7.5 meters long is suggested, for Angled Parking 2.4 to 3 m is suggested.")@Hidden
attr Right_Parking_Length		= _ParkingLength(Right_Parking_Type)
@Order(4)@Enum("None","Parallel","Angled Nose In","Angled Back In", "Parallel with Curbside Passenger Loading", "Parallel with Curbside Freight Loading","Parallel with Curbside Carshare Parking","Parallel with Curbside Bus Stop","Parallel with Curbside DoBi & Scooter Parking")@Description("Will create parking of that type with default lengths and widths. Keep in mind, adjusting the length/width will make it lock onto that value. To reset it to automatic default, set the Attribute Connection Editor back to rule-defined value.")
attr Left_Parking_Type			= "None"
@Order(5)@Distance @Range(min=0,max=5) @Description("Good default is 8 feet (2.4384 m) with a minimum of 7 feet (2.1336 m) for low turn over locations for parallel parking. Angled parking varies on angle, but a 30-45 degree depth suggestion is 19 feet (5.7912 m). Design guidance on width varies with conditions.")@Hidden
attr Left_Parking_Width			= _ParkingWidth(Left_Parking_Type) 
@Order(6)@Distance @Range(min=0,max=10)@Description("For Parallel Parking 6.1 to 7.5 meters long is suggested, for Angled Parking 2.4 to 3 m is suggested.")@Hidden
attr Left_Parking_Length		= _ParkingLength(Left_Parking_Type)
@Order(7)@Distance @Range(min=0,max=1)@Percent @Description("Will create Parklets in Parking spaces, it is best if the parking spaces are contiguous to the sidewalk. The default OBJ does not have bollards or curb stops suggested by NACTO.")
attr Parklet_Percentage			= 0
@Order(9)@Enum("None","Mid-Block & End Spaces","End Spaces","Far-side","Near-side","Mid-Block") @Description("Describes where on the street reallocated street space is used in parking lanes for parallel parking with curbside management options.")@Hidden
attr Curbside_Management_Position = case streetLength<20: "Far-side" else: "End Spaces"
@Handle(shape=RightCurbsideAllocator^4,axis=x,type=linear,color="#FF11FF")
@Order(10) @Distance @Range(min=0,max=50) @Description("This parameter represents the size of a curbside allocation on the right side of the street.")@Hidden
attr Right_Curbside_Allocation_Length = case find(Right_Parking_Type,"Bus",0)!=-1: 3 * Right_Parking_Length case find(Right_Parking_Type,"Loading",0)!=-1: 2 * Right_Parking_Length else: Right_Parking_Length
@Handle(shape=LeftCurbsideAllocator^4,axis=x,type=linear,color="#FF11FF")
@Order(11) @Distance @Range(min=0,max=50) @Description("This parameter represents the size of a curbside allocation on the left side of the street.")@Hidden
attr Left_Curbside_Allocation_Length = case find(Left_Parking_Type,"Bus",0)!=-1: 3 * Left_Parking_Length case find(Left_Parking_Type,"Loading",0)!=-1:2 * Left_Parking_Length else: Left_Parking_Length
@Order(12)@Distance @Range(min=0,max=10) @Hidden @Description("This hidden attribute controls the spacing the parking areas have before the current directions stopbar.")
attr Front_Parking_Spacing 		= 0
@Order(13)@Distance @Range(min=0,max=10) @Hidden @Description("This hidden attribute controls the spacing the parking areas have after the crosswalk at the start of the street in the current direction.")
attr Rear_Parking_Spacing		= 0


@Group("CENTER SECTION LAYOUT","Basic Attributes", 2) 
@Order(1) @Enum("None","Yellow Centerline","Median", "Boulevard", "Barrier","Barrier & Shoulder","Center Turn Lane","Median With Turn Lane","White Stripe Centerline","White Centerline")@Description("This attribute is key to picking a center type. If none, it is a centerline, but each choice creates different center section layouts.")
attr Center_Type						= "Yellow Centerline"
@Order(2) @Distance @Range(min=0,max=40) @Description("Is the combined center section width regardless of type. Does nothing for the barrier selection.")
attr Center_Width						= _getInitialCenterWidth
@Order(3) @Distance @Range(min=0,max=4) @Description("Is the width of the walkways created by Median. They will override the planting width, and keep in mind there are two walkways for Plant:Walk:Plant.")
attr WalkWay_Width 						= case Center_Width<=Median_Layout_Threshold: 0 else: 3+Median_Walkway_Expansion
@Order(4) @Enum("Walk:Plant:Walk","Walk:Plant","Plant:Walk","Plant:Walk:Plant") @Description("Lays out the median/boulevard walkway configurations. In the case of Plant:Walk:Plant-the walkway rule is used twice so adjust walkway width accordingly.") 
attr Planting_and_Walkway_Layout		="Walk:Plant:Walk"
@Order(5) @Distance @Range(min=0,max=10)@Description("In the case of a boulevard, this is the combined width for the lanes and center between the walkways. Each lane set gets half allocated space. Keep in mind this means there is forced symmetry in lanes.")
attr Boulevard_Inside_Width				= 7.1
@Order(6) @Enum("Normal Lanes","Bus Lanes", "Open Space","Cycle Path") @Description("Determines the general configurations of the inside of the boulevard. Normal lanes will be equal to the general Lane_Width, and any left over is filled with drainage filler.")
attr Boulevard_Configuration			= "Normal Lanes"
@Order(7) @Enum("Center Line","Median","Curb Buffer","Chain Link Fence", "Gate Fence","Tubular Markers")@Description("Will create the exact center of the lanes in the boulevard. To remove it set the width ==0.")
attr Boulevard_Center_Type				= "Center Line"
@Order(8)@Distance @Range(min=0,max=10)@Description("Determines the width of the center of the Boulevard lanes.")
attr Boulevard_Center_Width				= case Boulevard_Configuration=="Normal Lanes": PaintLineWidth*4 else: 0

@Group("CENTER SECTION LAYOUT","Median Plantings",3)@Order(1)
@Description("Chooses the grass texture for the planting locations within the Median.")@Enum("None","Random", "Standard Grass", "Gravel","Grate","Lawn 1", "Lawn 2", "Park", "Bermuda 1", "Bermuda 2", "Bermuda Dark", "Bluegrass 1", "Bluegrass 2", "Grass Short", "Grass Thick", "St Augustine 1", "St Augustine 2", "Light Rye","Soil Small Stones","Paver Red Octagon Tile") @Order(2)
attr Median_Ground_Cover = "Standard Grass"
@Order(4)@Distance @Range(min=0,max=10) @Description("Is the approximate length of the green space accomodating trees, it can be used to space out trees more without walkway spacing.")
attr Median_Planting_Length				= case Center_Width<=Median_Layout_Threshold: 8+Speed_Related_Expansion else: 4
@Order(5) @Distance @Range(min=0,max=15) @Description("Creates a walkway spacing between created trees.")
attr Median_Tree_Spacing				= case Center_Width<=Median_Layout_Threshold: 0 else: 3
@Order(6)@Description("Determines the species of the tree/plant selected for Tree 1. Random picks from 5 common tree types and is a good default.")@Enum("Random","Alder Buckthorn","Amazon Sword Plant","American Chestnut","American Sycamore","Apricot","Australian Pine","Baldcypress","Balsam Fir","Bamboo","Banana Tree","Basswood","Bay Laurel","Black Locust","Blue Gum Eucalyptus","Boxwood","Cabbage Palm Fern","California Bay","California Incense Cedar","California Palm","California Redwood","California Walnut","Coconut Palm","Common Hawthorn","Common Whitebeam","Conker Tree","Date Palm","Desert Willow","Douglas Fir","European Beech","European Larch","Ficus","Field Elm","Flannelbush","Flowering Dogwood","Giant Sequoia","Hedgehog Agave","Japanese Angelica Tree","Lacy Tree Philodendron","Leyland Cypress","Lily of the Valley","Lodgepole Pine","Mediterranean Buckthorn","Mexican Palmetto","Mountain Mahogany","Northern Red Oak","Norway Maple","Norway Spruce","Orange Tree","Orchid","Oval-leaved Privet","Palm Lily","Palo Verde","Paper Birch","Parlour Palm","Prickly Pear Cactus","Red Alder","Red Hickory","Rhododendron Azaleas","Rose","Ruffle Palm","Saguaro Cactus","Sassafras","Scots Pine","Sea Islands Yucca","Shadbush","Snake Plant","Southern Magnolia","Spanish Broom","Strawberry Tree","Sugar Maple","Sunflower","Sweetgum","Umbrella Acacia","Western Juniper","White Ash","White Oak","White Poplar","White Willow","Witch Hazel","","_____________________________","GENERICS","","Generic Dead Tree","Generic Stump","Generic Unknown","","_____________________________","PROXIES","","Algarrobo","American Elderberry","American Pepper","American Silverberry","Athel Tamarisk","Avocado","Black Tupelo","Buttonbush","Canada Buffaloberry","Chinaberry Tree","Chinese Tallow Tree","Common Hackberry","Common Holly","Common Persimmon","Desert Bitterbrush","European Hornbeam","Giant Chinquapin","Honey Locust","Hophornbeam","Huckleberry Shrub","Japanese Hemlock","Japanese Nutmeg","Judas Tree","Lawson Cypress","Loblolly Bay","Mexican Buckeye","Necklacepod","Northern Bilberry","Northern White Cedar","Octopus Tree","Osage Orange","Paper Bark Tree","Pawpaw","Persian Silk Tree","Princess Tree","Smooth Sumac","Sourwood","Southern Wax Myrtle","Tanoak","Tree of Heaven","Turkish Hazel","Western Soapberry","White Mulberry","Yellow Poplar","Yew")
attr Median_Tree_1_Type = "Random"
@Order(7)@Range(min=0,max=1)@Percent @Description("Reduces the probability of Tree 1 appearing in a typical designated location.")@Hidden
attr Median_Tree_1_Percentage 			= 1
@Order(8)@Description("Determines the species of the tree/plant selected for secondary tree for more variation. If this is not None, Tree 2 will appear if Tree 1 does not fire with the current percentage. This does mean that you cannot drop tree density if you alternate trees.")@Enum("None","Random","Alder Buckthorn","Amazon Sword Plant","American Chestnut","American Sycamore","Apricot","Australian Pine","Baldcypress","Balsam Fir","Bamboo","Banana Tree","Basswood","Bay Laurel","Black Locust","Blue Gum Eucalyptus","Boxwood","Cabbage Palm Fern","California Bay","California Incense Cedar","California Palm","California Redwood","California Walnut","Coconut Palm","Common Hawthorn","Common Whitebeam","Conker Tree","Date Palm","Desert Willow","Douglas Fir","European Beech","European Larch","Ficus","Field Elm","Flannelbush","Flowering Dogwood","Giant Sequoia","Hedgehog Agave","Japanese Angelica Tree","Lacy Tree Philodendron","Leyland Cypress","Lily of the Valley","Lodgepole Pine","Mediterranean Buckthorn","Mexican Palmetto","Mountain Mahogany","Northern Red Oak","Norway Maple","Norway Spruce","Orange Tree","Orchid","Oval-leaved Privet","Palm Lily","Palo Verde","Paper Birch","Parlour Palm","Prickly Pear Cactus","Red Alder","Red Hickory","Rhododendron Azaleas","Rose","Ruffle Palm","Saguaro Cactus","Sassafras","Scots Pine","Sea Islands Yucca","Shadbush","Snake Plant","Southern Magnolia","Spanish Broom","Strawberry Tree","Sugar Maple","Sunflower","Sweetgum","Umbrella Acacia","Western Juniper","White Ash","White Oak","White Poplar","White Willow","Witch Hazel","","_____________________________","GENERICS","","Generic Dead Tree","Generic Stump","Generic Unknown","","_____________________________","PROXIES","","Algarrobo","American Elderberry","American Pepper","American Silverberry","Athel Tamarisk","Avocado","Black Tupelo","Buttonbush","Canada Buffaloberry","Chinaberry Tree","Chinese Tallow Tree","Common Hackberry","Common Holly","Common Persimmon","Desert Bitterbrush","European Hornbeam","Giant Chinquapin","Honey Locust","Hophornbeam","Huckleberry Shrub","Japanese Hemlock","Japanese Nutmeg","Judas Tree","Lawson Cypress","Loblolly Bay","Mexican Buckeye","Necklacepod","Northern Bilberry","Northern White Cedar","Octopus Tree","Osage Orange","Paper Bark Tree","Pawpaw","Persian Silk Tree","Princess Tree","Smooth Sumac","Sourwood","Southern Wax Myrtle","Tanoak","Tree of Heaven","Turkish Hazel","Western Soapberry","White Mulberry","Yellow Poplar","Yew") @Hidden
attr Median_Tree_2_Type				= "None"
@Order(9) @Distance @Range(min=0,max=25,restricted=false) @Description("This attributes controls the height of Median Trees Type 1.") @Hidden
@Handle(shape=Median_Tree_Insert_Setup_1^3,axis=y,type=linear,reference=center,color="#11FF11",skin=sphere)
attr Median_Tree_1_Height = Tree._heightMin(Tree._indexFromCommonName(Sidewalk_Tree_1_Type))
@Order(10) @Distance @Range(min=0,max=25,restricted=false) @Description("This attributes controls the height of Median Trees Type 2.")@Hidden
@Handle(shape=Median_Tree_Insert_Setup_2^3,axis=y,type=linear,reference=center,color="#11FF11",skin=sphere)
attr Median_Tree_2_Height = Tree._heightMin(Tree._indexFromCommonName(Sidewalk_Tree_2_Type))
@Order(11) @Percent @Range(min=0,max=5) @Description("This attribute controls the random deviation that applies to tree heights. As a percent of total height.")
attr Median_Tree_Height_Deviation = case Not_Low_LOD: 0.1 else: 0 
@Group("CENTER SECTION LAYOUT","Basic Components", 4) 
@Order(5)@Enum("None","Both","Right","Left") @Description("Determines whether an object is placed and what side of the street or walkways relevant objects are placed.")
attr Median_Bus_Stop					="None"
@Order(6) @Enum("Far-side", "Mid-Block", "Near-side")@Description("Locates bus stop in the appropriate location. Far-side is right after the last intersection, Mid-Block is in the middle of the street, and Near-side is near to the next intersection.")
attr Median_Bus_Stop_Location			= "Far-side"
@Order(7)@Enum("true","false")@Description("Will create 2 bike racks near a bus stop.")@Hidden
attr Median_Bike_Rack					= "false"		
@Order(8)@Enum("true","false")@Description("Will create a WayFinder near a bus stop.")@Hidden
attr Median_Way_Finder					= "false"
@Order(9)@Enum("None","Both","Right","Left") @Description("Creates benches on the edges of the walkways of the Median.")
attr Median_Benches						="None"
@Order(10)@Distance @Range(min=0,max=25,restricted=false) @Description("Determines the spacing between each Bench. No shape is created in the sections in between objects.")@Hidden
attr Median_Bench_Spacing				=10
@Order(11)@Enum("None","Both","Right","Left")@Description("Determines whether an object is placed and what side of the street or walkways relevant objects are placed.")
attr Median_Street_Lamps						="Both"
@Order(12)@Distance @Range(min=0,max=25,restricted=false) @Description("Determines the spacing between each Street Lamp. No shape is created in the sections in between objects.")@Hidden
attr Median_Street_Lamp_Spacing				=10
@Order(9)@Distance @Range(min=-10,max=10) @Description("Determines the offset from the initial lamp insertion between each Street Lamp.")@Hidden
attr Median_Street_Lamp_Offset		= -3.5

@Group("MULTIMODAL LANES LAYOUT", "Bus and HOV Lanes",4)@Order(1)@Enum("None","Bus Lane","HOV Lane","Bus-Bike Lane","Light Rail Lane")@Description("The controls for the bus lane also control the HOV lane. They are grouped together because they are both considered :High Capacity Lanes:")
attr Transit_Lane 				    ="None"
@Order(2)@Enum("Right", "Left", "Both")@Description("Determines side of street preferential lanes are allocated.")
attr Transit_Lane_Sides 			=_Initital_Transit_Lane_Sides # If the street is oneway, will make initial bus lane side change accordingly
@Order(3) @Distance @Range(min=3,max=5) @Description("Determines the lane width of transit lanes that are not Dedicated Median Bus Lanes. NACTO suggested width is 11 feet (3.3528 m) minimum for Curb side and Median bus lanes, but allows for 10 feet (3.048 m) on Off-set bus lanes.")
attr Transit_Lane_Width			=  3.3528
@Order(3)@Enum("Sidewalk Side","Right Most Lane","Left Most Lane")@Description("Inserts a transit lane at the location specified. Keep in mind this is an insertion not a lane reallocation.")
attr Transit_Lane_Position 			="Right Most Lane"
@Order(4)@Distance @Range(min=1,max=100,restricted=false)@Description("MUTCD- Preferential Lanes: Markings spaced as close as 80 feet(~24.5 m) apart might be appropriate on city streets, while markings spaced as far as 1,000 feet (304.8 m) apart might be appropriate for freeways.")@Hidden
attr Transit_Symbol_Spacing 		= 24.5
@Order(6)@Enum("red","black") @Description("NACTO-Red colored paint should be applied to emphasize the lane and to deter drivers from using it. Red paint has higher installation and maintenance costs, but has been shown to deter both unauthorized driving and parking in the bus lane.")
attr Bus_Lane_Color				="red"
@Order(7)@Enum("Both","Right", "Left", "None")@Description("Controls the white lines on the sides of preferential lanes.")@Hidden
attr Transit_Paint_Line_Sides		= "Both"

@Group("MULTIMODAL LANES LAYOUT", "Bike Lanes",5)@Order(1)@Distance @Range(min=0,max=6) @Description("Desirable bike lane width adjacent to a curbface is 6 feet (1.8288m), but rideable surface adjacent  to a street edge is 4 feet (1.2192m) with minimum of 3 feet (0.9144m). In areas where illegal parking is an issue, at least 5 feet (1.524m) is suggested.")
attr Right_Bike_Lane_Width 		=0
@Order(2)@Distance @Range(min=0,max=6)@Description("Desirable bike lane width adjacent to a curbface is 6 feet (1.8288m), but rideable surface adjacent  to a street edge is 4 feet (1.2192m) with minimum of 3 feet (0.9144m). In areas where illegal parking is an issue, at least 5 feet (1.524m) is suggested.")
attr Left_Bike_Lane_Width		=0
@Order(3)@Enum("One-way","Two-way","Sharrow","Sidewalk","Two-way Sidewalk","One-way Reverse","Two-way Reverse","Sidewalk Reverse","Two-way Sidewalk Reverse")@Description("The one-way option uses the full lane width for each lane, while the two-way option will allocate half of the width to each sub-lane. Reverse will change the direction of the bike lane.")
attr Bike_Lane_Type				="One-way"
@Order(4)@Distance @Range(min=0,max=6)@Description("Bicycle Buffers have desired minimums of about 3 feet, but should be at least 18 inches wide because it is impractical to mark a zone narrower than that.")
attr Right_Buffer_Width			= 0
@Order(5)@Distance @Range(min=0,max=6)@Description("Bicycle Buffers have desired minimums of about 3 feet, but should be at least 18 inches wide because it is impractical to mark a zone narrower than that.")
attr Left_Buffer_Width			= 0
@Order(6)@Enum("true","false")@Description("If on/true, buffer is closer to the through lane, and bicycle lane is protected from through traffic.")
attr Buffer_Protection			= "true"
@Order(7) @Enum("true","false") @Description("If on/true, parking lane is closer to the through lane, and bicycle lane is protected from through traffic. Keep in mind how the door zone influences bicycle lane placement.")
attr Parking_Protection 		= _IsCycleTrackBuffer
@Order(8)@Enum("Painted Stripes","Curb Buffer","Curb Buffer with Plantings","Curb Buffer with Trees","Solid White","Cycle Track With Planters","Cycle Track With Tubular Markers","Cycle Track With Bollards","Spaced Curb Buffer","Spaced Curb Buffer with Plantings","Spaced Curb Buffer with Trees","Asphalt","Shoulder")@Description("This attribute controls the bicycle buffer type and form, but also can become plain asphalt or a shoulder.")
attr Buffer_Type				="Painted Stripes"
@Order(9)@Distance @Range(min=0,max=10)@Description("Controls  the buffers spacing of objects such as tubular markers, planters, and tree/plantings (Trees/Plants match Sidewalk Plantings if selected).")@Hidden			
attr Buffer_Object_Spacing		=_Default_Buffer_Object_Spacing
@Order(10)@Distance @Range(min=1,max=100,restricted=false)@Description("MUTCD- Preferential Lanes: Markings spaced as close as 80 feet (~24.5 m) apart might be appropriate on city streets, while markings spaced as far as 1,000 feet (304.8 m) apart might be appropriate for freeways.")@Hidden
attr Bike_Symbol_Spacing		= 24.5
@Order(11)@Distance @Range(min=0,max=20) @Description("Creates conflict spacing made up by asphalt gaps in the bike lane for approaching interesections.")
attr Bike_Conflict_Spacing		= 0
@Order(12)@Enum("green","black","red","blue","yellow") @Description("Determines the color of the bike lane and bike box. Paint reporting costs adjust based on color choices.")
attr Bike_Lane_Color			= case Bike_Lane_Type=="Sharrow" &&_Maxof(Left_Bike_Lane_Width,Right_Bike_Lane_Width)==0:"green" else: "black"
@Order(13)@Enum("Both","Right", "Left", "None")@Description("Controls the white lines on the sides of preferential lanes.")@Hidden
attr Bike_Paint_Line_Sides  	="Both"
@Order(14)@Enum("Rare","Moderate","Frequent")@Description("Is a descriptive attribute relating to the probability that a bike lane might be blocked due to unloading or double parking that feeds into Thematic.")@Hidden
attr Level_of_Blockage			="Rare"

@Group("MULTIMODAL LANES LAYOUT","Bike Box",6)
@Order(1) @Enum("true","false") @Description("Right Side Bike Box: NACTO-A bike box is a designated area at the head of a traffic lane at a signalized intersection that provides bicyclists with a safe and visible way to get ahead of queuing traffic during the red signal phase. Works best if bike lane is adjacent to sidewalk.")
attr Right_Bike_Box				= "false"
@Order(2) @Enum("true","false") @Description("Left Side Bike Box: NACTO-A bike box is a designated area at the head of a traffic lane at a signalized intersection that provides bicyclists with a safe and visible way to get ahead of queuing traffic during the red signal phase. Works best if bike lane is adjacent to sidewalk.")
attr Left_Bike_Box				= "false"
@Order(3)@Distance @Range(min=1,max=10) @Description("Is the best fit spacing between the bicycle symbols on the bike box. Can be increased to reduce the number of symbols created.")@Hidden
attr Bike_Box_Symbol_Spacing	= 5
@Order(4)@Distance @Range(min=0,max=5.3768)@Description("NACTO-A box formed by transverse lines shall be used to hold queuing bicyclists, typically 10-16  feet deep (3.048-4.8768 M). Deeper boxes show less encroachment by motor vehicles.")@Hidden
attr Bike_Box_Length			= 4.26
@Order(12)@Enum("green","black","red","blue","yellow") @Description("By default, the Bike Box will match the color of the bike lane, but this attribute can be adjusted to override that choice. Paint reporting costs adjust based on color choices.")
attr Bike_Box_Color_Override	= Bike_Lane_Color

@Group("SIDEWALK LAYOUT","Sidewalk Attributes",7)@Description("Provides a file picker for the texture choice. This attribute also controls the curb buffer and median walkway textures.")
@Order(2)@File ("tif","jpg","png","tiff","gif","jpeg","psp","jsl","sgi","tga","bmp","dds")
attr Sidewalk_Texture 				= Default_Pavement
@Order(3) @Range(min=0.1,max=10)@Description("Adjust the scale of the sidewalk texture.This attribute also controls the curb buffer and median walkway textures.")
attr Sidewalk_Texture_Scale 		= 1
@Order(4) @Range(min=0,max=360)@Description("Adjust the angle of the sidewalk texture. This attribute also controls the curb buffer and median walkway textures.")
attr Sidewalk_Texture_Rotation		= 0
@Order(5) @Distance @Range(min=0,max=0.4)@Description("Determines the height of the sidewalk. Default is 4 inches tall.  This attribute also controls the curb buffer and median walkway textures.")
attr Sidewalk_Height 				= 0.102  			# height of sidewalk of curbs(4 inch is standard thickness) curb depth is 1.5 times sidewalk height
@Group("SIDEWALK LAYOUT", "Sidewalk Plantings + Zones",8)
@Description("Chooses the grass texture for the planting locations on the Sidewalk or Center Island. Bus Stops and trees will not generate if this is set to None.")@Enum("None","Random", "Standard Grass", "Gravel","Grate","Lawn 1", "Lawn 2", "Park", "Bermuda 1", "Bermuda 2", "Bermuda Dark", "Bluegrass 1", "Bluegrass 2", "Grass Short", "Grass Thick", "St Augustine 1", "St Augustine 2", "Light Rye","Soil Small Stones","Paver Red Octagon Tile") @Order(2)
attr Sidewalk_Ground_Cover			= "None"
@Order(2)@Distance @Range(min=0,max=10)@Description("Controls the width of the furniture zone (space between the planting and the curb).")
attr Sidewalk_Furniture_Zone_Width		= CurbtoPlantingGap
@Order(3)@Distance @Range(min=0,max=10)@Description("Controls the right width of the furniture zone (space between the planting and the curb).")@Hidden
attr Right_Sidewalk_Furniture_Zone_Width= Sidewalk_Furniture_Zone_Width	 
@Order(4)@Distance @Range(min=0,max=10)@Description("Controls the left width of the furniture zone (space between the planting and the curb).")@Hidden
attr Left_Sidewalk_Furniture_Zone_Width= Sidewalk_Furniture_Zone_Width	
@Order(5)@Distance @Range(min=0,max=10)@Description("Controls the width of sidewalk planting space, and the setback of the bus stop.")
attr Sidewalk_Planting_Width		= _PlantingWidth
@Order(6)@Distance @Range(min=0,max=10)@Description("Controls the right sidewalk side width of sidewalk planting space, and the setback of the bus stop.")@Hidden
attr Right_Sidewalk_Planting_Width= Sidewalk_Planting_Width 
@Order(7)@Distance @Range(min=0,max=10)@Description("Controls the left sidewalk side width of sidewalk planting space, and the setback of the bus stop.")@Hidden
attr Left_Sidewalk_Planting_Width= Sidewalk_Planting_Width 
@Order(8)@Distance @Range(min=0,max=10)  @Description("Is the approximate length of the green space accommodating trees, it can be used to space out trees more without walkway spacing.")
attr Sidewalk_Planting_Length 		= 5
@Order(9)@Distance @Range(min=0,max=20)@Description("Creates a walkway spacing between created trees. Keep in mind that the benches are placed in this spacing and must be an appropriate size to accommodate them.")@Hidden
attr Sidewalk_Planting_Spacing 		= 5
@Group("SIDEWALK LAYOUT","Sidewalk Trees",9)
@Order(10)@Description("Determines the species of the tree/plant selected for Tree 1. Random picks from 5 common tree types and is a good default.")@Enum("Random","Alder Buckthorn","Amazon Sword Plant","American Chestnut","American Sycamore","Apricot","Australian Pine","Baldcypress","Balsam Fir","Bamboo","Banana Tree","Basswood","Bay Laurel","Black Locust","Blue Gum Eucalyptus","Boxwood","Cabbage Palm Fern","California Bay","California Incense Cedar","California Palm","California Redwood","California Walnut","Coconut Palm","Common Hawthorn","Common Whitebeam","Conker Tree","Date Palm","Desert Willow","Douglas Fir","European Beech","European Larch","Ficus","Field Elm","Flannelbush","Flowering Dogwood","Giant Sequoia","Hedgehog Agave","Japanese Angelica Tree","Lacy Tree Philodendron","Leyland Cypress","Lily of the Valley","Lodgepole Pine","Mediterranean Buckthorn","Mexican Palmetto","Mountain Mahogany","Northern Red Oak","Norway Maple","Norway Spruce","Orange Tree","Orchid","Oval-leaved Privet","Palm Lily","Palo Verde","Paper Birch","Parlour Palm","Prickly Pear Cactus","Red Alder","Red Hickory","Rhododendron Azaleas","Rose","Ruffle Palm","Saguaro Cactus","Sassafras","Scots Pine","Sea Islands Yucca","Shadbush","Snake Plant","Southern Magnolia","Spanish Broom","Strawberry Tree","Sugar Maple","Sunflower","Sweetgum","Umbrella Acacia","Western Juniper","White Ash","White Oak","White Poplar","White Willow","Witch Hazel","","_____________________________","GENERICS","","Generic Dead Tree","Generic Stump","Generic Unknown","","_____________________________","PROXIES","","Algarrobo","American Elderberry","American Pepper","American Silverberry","Athel Tamarisk","Avocado","Black Tupelo","Buttonbush","Canada Buffaloberry","Chinaberry Tree","Chinese Tallow Tree","Common Hackberry","Common Holly","Common Persimmon","Desert Bitterbrush","European Hornbeam","Giant Chinquapin","Honey Locust","Hophornbeam","Huckleberry Shrub","Japanese Hemlock","Japanese Nutmeg","Judas Tree","Lawson Cypress","Loblolly Bay","Mexican Buckeye","Necklacepod","Northern Bilberry","Northern White Cedar","Octopus Tree","Osage Orange","Paper Bark Tree","Pawpaw","Persian Silk Tree","Princess Tree","Smooth Sumac","Sourwood","Southern Wax Myrtle","Tanoak","Tree of Heaven","Turkish Hazel","Western Soapberry","White Mulberry","Yellow Poplar","Yew")
attr Sidewalk_Tree_1_Type				= "Random"
@Order(11) @Range(min=0,max=1) @Percent @Description("Reduces the probability of Tree 1 appearing in a typical designated location, but also controls the Tree quantity at round abouts.")@Hidden
attr Sidewalk_Tree_1_Percentage 		= 1
@Order(12)@Description("Determines the species of the tree/plant selected for secondary tree for more variation. If this is not None, Tree 2 will appear if Tree 1 does not fire with the current percentage. This does mean that you cannot drop tree density if you alternate trees.")@Enum("None","Random","Alder Buckthorn","Amazon Sword Plant","American Chestnut","American Sycamore","Apricot","Australian Pine","Baldcypress","Balsam Fir","Bamboo","Banana Tree","Basswood","Bay Laurel","Black Locust","Blue Gum Eucalyptus","Boxwood","Cabbage Palm Fern","California Bay","California Incense Cedar","California Palm","California Redwood","California Walnut","Coconut Palm","Common Hawthorn","Common Whitebeam","Conker Tree","Date Palm","Desert Willow","Douglas Fir","European Beech","European Larch","Ficus","Field Elm","Flannelbush","Flowering Dogwood","Giant Sequoia","Hedgehog Agave","Japanese Angelica Tree","Lacy Tree Philodendron","Leyland Cypress","Lily of the Valley","Lodgepole Pine","Mediterranean Buckthorn","Mexican Palmetto","Mountain Mahogany","Northern Red Oak","Norway Maple","Norway Spruce","Orange Tree","Orchid","Oval-leaved Privet","Palm Lily","Palo Verde","Paper Birch","Parlour Palm","Prickly Pear Cactus","Red Alder","Red Hickory","Rhododendron Azaleas","Rose","Ruffle Palm","Saguaro Cactus","Sassafras","Scots Pine","Sea Islands Yucca","Shadbush","Snake Plant","Southern Magnolia","Spanish Broom","Strawberry Tree","Sugar Maple","Sunflower","Sweetgum","Umbrella Acacia","Western Juniper","White Ash","White Oak","White Poplar","White Willow","Witch Hazel","","_____________________________","GENERICS","","Generic Dead Tree","Generic Stump","Generic Unknown","","_____________________________","PROXIES","","Algarrobo","American Elderberry","American Pepper","American Silverberry","Athel Tamarisk","Avocado","Black Tupelo","Buttonbush","Canada Buffaloberry","Chinaberry Tree","Chinese Tallow Tree","Common Hackberry","Common Holly","Common Persimmon","Desert Bitterbrush","European Hornbeam","Giant Chinquapin","Honey Locust","Hophornbeam","Huckleberry Shrub","Japanese Hemlock","Japanese Nutmeg","Judas Tree","Lawson Cypress","Loblolly Bay","Mexican Buckeye","Necklacepod","Northern Bilberry","Northern White Cedar","Octopus Tree","Osage Orange","Paper Bark Tree","Pawpaw","Persian Silk Tree","Princess Tree","Smooth Sumac","Sourwood","Southern Wax Myrtle","Tanoak","Tree of Heaven","Turkish Hazel","Western Soapberry","White Mulberry","Yellow Poplar","Yew")@Hidden
attr Sidewalk_Tree_2_Type				= "None"
@Order(13) @Distance @Range(min=0,max=25,restricted=false) @Description("This attributes controls the height of Sidewalk Trees Type 1.")
@Handle(shape=Sidewalk_Tree_Insert_Setup_1^3,axis=y,type=linear,reference=center,color="#11FF11",skin=sphere) @Hidden
attr Sidewalk_Tree_1_Height = Tree._heightMin(Tree._indexFromCommonName(Sidewalk_Tree_1_Type))
@Order(14) @Distance @Range(min=0,max=25,restricted=false) @Description("This attributes controls the height of Sidewalk Trees Type 2.") @Hidden
@Handle(shape=Sidewalk_Tree_Insert_Setup_2^3,axis=y,type=linear,reference=center,color="#11FF11",skin=sphere)
attr Sidewalk_Tree_2_Height = Tree._heightMin(Tree._indexFromCommonName(Sidewalk_Tree_2_Type))@Hidden
Tree_Radius(Type, Height) = Tree._radius(Tree._indexFromCommonName(Type),Height)
@Order(15) @Percent @Range(min=0,max=5) @Description("This attribute controls the random deviation that applies to tree heights. As a percent of total height.")
attr Sidewalk_Tree_Height_Deviation = case Not_Low_LOD: 0.1 else: 0
@Order(16) @Enum("None","Curb") @Description("This parameter determines what type of border planting boxes have in inserted locations.")
attr Sidewalk_Planting_Border = case Not_Low_LOD : "Curb" else :"None"

@Group("SIDEWALK LAYOUT","Sidewalk Components",10)@Order(1)
@Order(1)@Enum("None","Both","Right","Left")@Description("Determines whether an object is placed and what side of the street or walkways relevant objects are placed.")
attr Sidewalk_Bus_Stop					="None"
@Order(2) @Enum("Far-side", "Mid-Block", "Near-side")@Description("Locates bus stop in the appropriate location. Far-side is right after the last intersection, Mid-Block is in the middle of the street, and Near-side is near to the next intersection.")
attr Sidewalk_Bus_Stop_Location			= "Far-side"
@Order(3) @Distance @Range(min=-4,max=4)@Description("As it stands, the Bus Stop will be as far back as the Planting Width, if more adjustment is required, this attribute can be used to set back the Bus Stop further back or move it closer to the curb.")
attr Sidewalk_Bus_Stop_Setback			= .5
@Order(4)@Enum("None","Both","Right","Left")@Description("Will place benches in between the spacing between Trees on the sidewalk side chosen.")
attr Sidewalk_Benches					=case Not_High_LOD || sidewalkWidth<4: "None" else: "Both"
@Order(5)@Enum("None","Both","Right","Left")@Description("Determines whether an object is placed and what side of the street or walkways relevant objects are placed.")
attr Parking_Meters						="None"
@Order(6)@Distance @Range(min=0,max=20) @Description("Determines the spacing between each parking meter. No shape is created in the sections in between objects.")@Hidden
attr Parking_Meters_Spacing				= 6.1
@Order(7) @Distance @Range(min=0,max=20) @Description("This attribute provides a way to adjust the starting location for parking meters so that they align with on-street parking.")@Hidden
attr Parking_Meter_Setback				= 9 #pushes or pulls parking meters away 
@Order(8)@Enum("None","Both","Right","Left")@Description("Determines whether an object is placed and what side of the street or walkways relevant objects are placed.")
attr Sidewalk_Street_Lamps				= case Not_High_LOD: "None" else: "Both"
@Order(9)@Distance @Range(min=0,max=50) @Description("Determines the spacing between each Street Lamp. No shape is created in the sections in between objects.")@Hidden
attr Sidewalk_Street_Lamp_Spacing		=10
@Order(9)@Distance @Range(min=-10,max=10) @Description("Determines the offset from the initial lamp insertion between each Street Lamp.")@Hidden
attr Sidewalk_Street_Lamp_Offset		=0
@Order(10)@Enum("None","Both","Right","Left")@Description("Determines whether an object is placed and what side of the street or walkways relevant objects are placed.")
attr Traffic_Lights						= case Not_High_LOD: "None" else: "Both"
@Order(11) @Enum("true","false") @Description("Will create a WayFinder near a bus stop.")@Hidden
attr Sidewalk_Way_Finder				="false"
@Order(12)@Enum("true","false") @Description("Will create 2 bike racks near a bus stop.")@Hidden
attr Sidewalk_Bike_Rack					="false"


@Group("POPULATION",80) @Range(min=0,max=300,restricted=false) @Order(1) 
@Description("Determines the number of vehicles per KM of road length loaded onto main throughways.")@Hidden
attr Vehicles_Per_KM 				= case Not_Very_High_LOD:0 else: 100
@Range(min=0,max=300,restricted=false) @Order(2)@Description("Determines the number of buses per KM of road length loaded onto bus lanes only.")@Hidden
attr Bus_Lane_Buses_Per_KM			= case Not_Very_High_LOD:0 else: 25
@Order(3) @Range(min=0,max=100,restricted=false)@Description("Determines the number of bicyclists per KM of road length loaded onto bike lanes only.")@Hidden
attr Bicycles_Per_KM				= case Not_Very_High_LOD:0 else: 80*_BikeRank
@Range(min=0,max=1) @Percent @Order(4)@Description("Determines the approximate percentage of vehicles that are buses on main throughways.")@Hidden		
attr Mixed_Traffic_Bus_Percentage	= Default_Mix_Bus
@Range(min=0,max=1) @Percent @Order(5)@Description("Determines the approximate percentage of vehicles that are bikes in the curb lane of main throughways.")@Hidden		
attr Mixed_Traffic_Bike_Percentage	= Default_Mix_Bike
@Range(min=0,max=1) @Percent @Order(6)@Description("Determines the approximate percentage of vehicles that are trucks  in the curb lane of main throughways.")@Hidden		
attr Mixed_Traffic_Freight_Percentage	= Default_Mix_Freight
@Range(min=0,max=1) @Percent @Order(7)@Description("Determines the approximate percentage of vehicles that are taxis on main throughways.")@Hidden		
attr Taxi_Percentage 				= Default_Mix_Taxi
@Order(7) @Percent @Range(min=0,max=1) @Description("Higher the percentage, the higher the number of people loaded onto sidewalks.")@Hidden
attr People_Percentage 				= case Not_Very_High_LOD:0 else: .9 *_PedRank
@Order(9)@Percent @Range(min=0,max=1) @Description("Higher the percentage, the higher the parking occupancy.")@Hidden
attr Parked_Car_Percentage			= case Not_Very_High_LOD:0 else: .6
@Order(10)@Hidden @Range(min=0,max=360) @Description("When parking is angled, this determines the angle of the vehicles placed in each right side angled parking spot.")
attr Right_Parked_Car_Angle			= _Car_Angle(Right_Parking_Type)
@Order(11)@Hidden @Range(min=0,max=360)@Description("When parking is angled, this determines the angle of the vehicles placed in each left side angled parking spot.")
attr Left_Parked_Car_Angle			= _Car_Angle(Left_Parking_Type)

@Group("CUSTOM OBJECTS",90) 
@Order(1)@File("glb","dae","dxf","gdb","kml","kmz","obj","osm","shp")@Description("Make sure object/3D files are aligned so that UP is aligned to the Y Axis. Keep in mind objs were inserted assuming a standard alignment.")@Hidden
attr Street_Lamp_Object						=Default_Lamp
@Order(2)@File("glb","dae","dxf","gdb","kml","kmz","obj","osm","shp")@Description("Make sure object/3D files are aligned so that UP is aligned to the Y Axis. Keep in mind objs were inserted assuming a standard alignment.")@Hidden
attr Parking_Meter_Object					=Default_Parking_Meter
@Order(3)@File("glb","dae","dxf","gdb","kml","kmz","obj","osm","shp")@Description("Make sure object/3D files are aligned so that UP is aligned to the Y Axis. Keep in mind objs were inserted assuming a standard alignment.")@Hidden
attr Traffic_Light_Object					= case streetWidth > 11: Default_Large_Traffic_Light else: Default_Small_Traffic_Light
@Order(4)@File("glb","dae","dxf","gdb","kml","kmz","obj","osm","shp")@Description("Make sure object/3D files are aligned so that UP is aligned to the Y Axis. Keep in mind objs were inserted assuming a standard alignment.")@Hidden
attr Wayfinder_Object						=Default_WayFinder
@Order(5)@File("glb","dae","dxf","gdb","kml","kmz","obj","osm","shp")@Description("Make sure object/3D files are aligned so that UP is aligned to the Y Axis. Keep in mind objs were inserted assuming a standard alignment.")@Hidden
attr Bench_Object							=Default_Bench
@Order(6)@File("glb","dae","dxf","gdb","kml","kmz","obj","osm","shp")@Description("Make sure object/3D files are aligned so that UP is aligned to the Y Axis. Keep in mind objs were inserted assuming a standard alignment.")@Hidden
attr Bike_Rack_Object						=Default_Bike_Rack
@Order(7)@File("glb","dae","dxf","gdb","kml","kmz","obj","osm","shp")@Description("Make sure object/3D files are aligned so that UP is aligned to the Y Axis. Keep in mind objs were inserted assuming a standard alignment.")@Hidden
attr Bus_Stop_Object						=Default_BusStop
@Order(8)@File("glb","dae","dxf","gdb","kml","kmz","obj","osm","shp")@Description("Make sure object/3D files are aligned so that UP is aligned to the Y Axis. Keep in mind objs were inserted assuming a standard alignment.")@Hidden
attr Parklet_Object							=Default_Parklet					
######################################################
#Bridge Attributes									 #
######################################################

@Group("BRIDGES",110) @Order(1) @Description("Determines the various conditions by which the bridge rule will turn on. Occulsion functions are used in the bridge rule and might have some errant behavior.")
@Enum("Off","Concrete Extrusion Only", "Dimension Extrusion","On, By Elevation","On, Regardless","On, Show All Piers")
attr Bridge_Display = "Off" 
@Group("BRIDGES") @Order(20) @Description("Determines the threshold distance above the standard elevation for the bridge rule to trigger based on Elevation.")@Hidden
attr Bridge_Starts_At = 3
@Group("BRIDGES") @Order(30) @Description("Determines how thick the supporting cement structure of the bridge is.")@Hidden
attr Bridge_Thickness = 1
@Group("BRIDGES") @Order(40) @Description("Determines the distance between Piers.")@Hidden
attr Pier_Distance = 23
@Group("BRIDGES") @Order(50) @Description("Determines the width of the Piers.")@Hidden
attr Pier_Width = 2.3


# Mapped Attributes (comming from graph)
#@Group("LINK TO OBJECT ATTRIBUTES",99)
@Hidden @Order(5)@Description("For internal use and reporting, must be set to 'Source=Object'.")
attr connectionEnd 				= "STREET"		# built in value attributes, needs to be sourced as Object (parent)
@Hidden @Order(6)@Description("For internal use and reporting, must be set to 'Source=Object'.")
attr connectionStart 			= "STREET"		# built in value attributes, needs to be sourced as Object (parent)
@Hidden @Order(7)@Description("For internal use and rep_getInitialCrosswalk(connectionStart)orting, must be set to 'Source=Object'.")
attr valency 					= 0
@Hidden @Order(8)@Description("For internal use and reporting, must be set to 'Source=Object'.")//If these two do not connect, crosswalks with have no default width-they must be connected. 
attr sidewalkWidthLeft			= (geometry.dv(0,unitSpace))
@Hidden @Order(9)@Description("For internal use and reporting, must be set to 'Source=Object'.")//If these two do not connect, crosswalks with have no default width-they must be connected. 
attr sidewalkWidthRight			= (geometry.dv(0,unitSpace))
@Hidden @Order(10) @Description("For internal use and reporting, must be set to 'Source=Object'.")
attr sidewalkWidth				= case sidewalkSide=="Right": sidewalkWidthRight else: sidewalkWidthLeft
@Hidden @Order(11) @Description("For internal use and reporting, must be set to 'Source=Object'.")
attr sidewalkLength				= 0
@Hidden @Order(12) @Description("For internal use and reporting, must be set to 'Source=Object'.")
attr sidewalkSide				= "Error"
@Hidden @Order(14) @Description("For internal use and reporting, must be set to 'Source=Object'.")
attr Thematics					= _GeneralThematic
@Order(15) @Hidden @Description("For internal use and reporting, must be set to 'Source=Object'.")
attr elevation = 0               # built in value attributes, needs to be sourced as Object (parent)
@Hidden @Order(16) @Description("For internal use and is designed to be mapped to the segement line so that a street can be used in flood visualization.")
attr Base_Flood_Elevation=-.00001
##################
# Handle Control #
##################
@Group("Handles",120)
@Handle(shape=LampAsset^1,axis=x,type=move,color="#DDDD11")
@Order(1)@Description("This parameter represents a handle that controls lamp translation.") @Hidden
attr SLight_Translate_X = Sidewalk_Furniture_Zone_Width/2
@Handle(shape=LampAsset^1,axis=z,type=move,color="#DDDD11") @Hidden
@Order(2)@Description("This parameter represents a handle that controls lamp translation.")
attr SLight_Translate_Z = Sidewalk_Furniture_Zone_Width/2
@Handle(shape=Traffic_Light^1,axis=z,type=angular,color="#FF1111") @Hidden
@Order(3)@Angle @Range(min=0,max=360)@Description("Determines the rotation of the signal pole at the intersection.")
attr Traffic_Light_Rotation = 180
@Handle(shape=Traffic_Light^1,axis=x,type=move,color="#FF1111")@Hidden
@Order(4)@Description("This parameter represents a handle that controls traffic light translation.")
attr TLight_Translate_X = 0
@Handle(shape=Traffic_Light^1,axis=y,type=move,color="#FF1111")@Hidden
@Order(5)@Description("This parameter represents a handle that controls traffic light translation.")
attr TLight_Translate_Z = 0
@Handle(shape=Bench_Insert,axis=x,type=move,color="#DD9922")@Hidden
@Order(6)@Description("This parameter represents a handle that controls bench translation.")
attr SBench_Translate_X = 0
@Handle(shape=Bench_Insert,axis=y,type=move,color="#DD9922")@Hidden
@Order(7)@Description("This parameter represents a handle that controls bench translation.")
attr SBench_Translate_Z = 0
@Handle(shape=Bench_Insert,type=toggle,color="#DD9922")@Enum(true,false) @Hidden
@Order(8)@Description("This parameter represents a handle that controls bench toggling.")
attr SBench_Toggle = true


##################
# User constants #
##################
#Folder Constants-Asset Links
const CompleteStreetFolder 			= case fileExists(fileRandom("Complete_Streets/Lanes*.jpg")):"Complete_Streets" else: "/ESRI.lib/assets/Streets"
const LanesFolder					= CompleteStreetFolder +"/Lanes"
const SidewalkFolder				= CompleteStreetFolder +"/Sidewalks"
const ObjectFolder					= CompleteStreetFolder +"/Street_Furniture_and_Objects"
const GrassFolder					= CompleteStreetFolder +"/Sidewalks/Grass"
const TrafficControlFolder			= ObjectFolder +"/Dir_Traffic_controls"
const LampsFolder					= ObjectFolder+"/Dir_Lamps"
const MiscFolder					= CompleteStreetFolder +"/Misc"
const StencilFolder					= ObjectFolder+ "/Stencil"
#Paint Constants
const Asphalt_Tile_Size				= 2.5
const Sidewalk_Tile_Size			= 2
const ThickPaintLineWidth			= 0.5
const ModeratePaintLineWidth		= 0.17
const PaintLineWidth				= 0.11 #uvSpace 36/256-about 4 in
const Rumble_Strip_Len				= 1.5 #FWHA 7 in wide per bump with 5 in ashpalt spacing
const Rumble_Strip_Wid				= .355 #FWHA-typically 12-16 in wide
const Stencil_Color 				= "white"
const Asphalt_Base  				= case !Not_Low_LOD: "asphalt_14x14m.jpg" else:"Asphalt003_2K_Color.jpg"
#SideWalk and Median Constants
const Centerline_Color				= case Center_Type == "White Centerline":"white" else: "yellow"
const Median_Layout_Threshold		= case find(Center_Type,"Turn Lane",0)!=-1:Lane_Width*3 else: Lane_Width*2
const Median_Walkway_Expansion		= ln(abs((Center_Width-Median_Layout_Threshold)/2))
const Speed_Related_Expansion		= ln(abs(Speed_Limit_in_MPH/5))
const Bench_Threshold_Width			= .9
const Bench_Adjuster				= 1
const Default_Pavement				= SidewalkFolder+"/Concrete Clean Light.jpg"
const CurbtoPlantingGap				=.15
const Curb_Depth					= 0.1574
const BusStop_Length				= 16.0
const Parklet_Shift					= case _Actual_Space_Management== "Best Fit" || (Parking_Protection_Bool && _Minof(Left_Buffer_Width+Street_Left_Bike_Lane_Width,Right_Buffer_Width+Street_Right_Bike_Lane_Width)>0):0 else:-_EmptySpace #if parking protection is on a shift will lead to geometric collision, but it will choose to collide if oneside does not have a bikelane/buffer (check later).   
const Max_Sidewalk_Gap				= 5.4 #change this if you want a smaller or larger gap between first tree splits and crosswalks
const Median_Turn_Transition_Depth  = Center_Width*(3*Speed_Limit_in_MPH/30)
const TWLTL_Turn_Pocket_Depth		= 13.75
const Total_Median_Turn_Depth 		= Median_Turn_Pocket_Depth + Median_Turn_Transition_Depth + ThickPaintLineWidth
const Total_TWLTL_Turn_Depth		= TWLTL_Turn_Pocket_Depth + Median_Turn_Transition_Depth + ThickPaintLineWidth
const Median_Turn_Pocket_Depth		= 14
const Minimum_Turn_Curb_Width		= 1.5/Feet
const Turn_Pocket_Curb_Width		= _Maxof(Minimum_Turn_Curb_Width,Center_Width/10)
const Dimension_Center_Hexcode		= case Boulevard_Configuration=="Bus Lanes": NACTOTransit 
									  case Boulevard_Configuration=="Normal Lanes": NACTOAuto 
									  case Boulevard_Configuration=="Cycle Path":NACTOBike 
									  case Boulevard_Configuration=="Open Space":NACTOPlanting
									  else: NACTOConflictZone
const Curb_Switch					= case streetWidth ==0:0 else: 1 
#Transit Lane Constants
#Bike Constants
const sharrowHeight					=0.005 * ceil(abs(geometry.angle(maxSlope)+1)/5)
const Buffer_StartGap				=.2
const BikeBox_Fraction				=.75
const Center_Tube_Marker_Dist		=.1
const L_to_W_Ratio_Bk			= 3 # MUTCD recommends a 72 in gap and length of symbol, gap, and arrows. Assuming a 6 ft lane, this is width of lane * 3
const _Default_Buffer_Object_Spacing= case Buffer_Type=="Curb Buffer with Trees":8 case find(Buffer_Type,"Spaced Curb",0)!=-1:6 case Buffer_Type=="Cycle Track With Planters":2.5 else:1.5
const BikeBoxGeometryThreshold		= Lane_Width *BikeBox_Fraction+_Maxof(Street_Right_Bike_Lane_Width,Street_Left_Bike_Lane_Width)-.1
const Street_Right_Bike_Lane_Width	=	case find(Bike_Lane_Type,"Sidewalk",0)!=-1:0 else:Right_Bike_Lane_Width
const Street_Left_Bike_Lane_Width	=	case find(Bike_Lane_Type,"Sidewalk",0)!=-1:0 else:Left_Bike_Lane_Width
const Sidewalk_Right_Bike_Lane_Width=	case find(Bike_Lane_Type,"Sidewalk",0)!=-1:Right_Bike_Lane_Width else:0
const Sidewalk_Left_Bike_Lane_Width	=	case find(Bike_Lane_Type,"Sidewalk",0)!=-1:Left_Bike_Lane_Width else:0
const Bike_Box_Buffer_Adapter		= case Buffer_Protection_Bool && Parking_Protection_Bool:1 else:0 #Helps with adjusting the stopbar to different buffer types. 
const Bike_Reversal_Switch			= case find(Bike_Lane_Type,"Reverse",0)!=-1:-1 else: 1
const _Twoway_Bikelane_Bool			= find(Bike_Lane_Type,"Two-way",0)!=-1 #Find(_)!=1 Pattern is ~ if it has this string, true.
#Transit Constants
const Track_Gauge					= 1.435 #Standard 
const Rail_Depth 					= .05
#Vegetation Constants
const Random_Grass					=(fileRandom(GrassFolder + "/*.jpg"))
#Parking Constants
const _Place_Colored_Curb			= case(find(Buffer_Type,"Curb",0)!=-1 || !Parking_Protection_Bool): true else: false
#Object Model Constants
const Default_Lamp					= (LampsFolder +"/Overhanging_Street_-_Light_off.glb")
const Default_Parking_Meter			= (ObjectFolder+ "/parkingMeter.obj")
const Default_Small_Traffic_Light	= (TrafficControlFolder+ "/Traffic_Light_1.glb")
const Default_Large_Traffic_Light	= (TrafficControlFolder+ "/Traffic_Light_2.glb")
const Default_WayFinder				= (ObjectFolder+ "/WayFinder.obj")
const Default_Bench					= (ObjectFolder+ "/Park_Bench_2.glb")
const Default_Bike_Rack				= (ObjectFolder+ "/Bike_Rack.obj")
const Default_Parklet				= (ObjectFolder+ "/Parklet_"+LOD_Object_Choice+"_LOD.obj")
const Default_BusStop				= (ObjectFolder+ "/Bus_Stop_2.glb")
const Default_Median_End			= (StencilFolder+ "/Median_End.obj")
const Default_Median_Transition		= (StencilFolder+"/Median_Transition.obj")
const Default_TWLTL_Transition      = (StencilFolder+"/Center_Turn_Lane_Transition.obj")
const Default_Wedge 				= (ObjectFolder+"/Wedge.obj")
const Max_Distance_From_CS_Manage   = 1.5
#Boolean Converted Constants
const Parking_Protection_Bool		= bool(Parking_Protection)#Bool Conversion to support non-boolean database models
const Buffer_Protection_Bool		= bool(Buffer_Protection)#Bool Conversion to support non-boolean database models
const Right_Bike_Box_Bool			= bool(Right_Bike_Box)#Bool Conversion to support non-boolean database models
const Left_Bike_Box_Bool			= bool(Left_Bike_Box)#Bool Conversion to support non-boolean database models
const Sidewalk_Way_Finder_Bool		= bool(Sidewalk_Way_Finder)#Bool Conversion to support non-boolean database models
const Sidewalk_Bike_Rack_Bool		= bool(Sidewalk_Bike_Rack)#Bool Conversion to support non-boolean database models
const Median_Way_Finder_Bool		= bool(Median_Way_Finder)#Bool Conversion to support non-boolean database models
const Median_Bike_Rack_Bool			= bool(Median_Bike_Rack)#Bool Conversion to support non-boolean database models
#####Reporting Constants#####
#Stop Distance Reporting Constants
#AASHTO Numbers of interest: Brake reaction time: 2.5 seconds (capabilities of most drivers), 90 percent deceleration rate: 11.2 ft/s^2- reports assume at grade-future iterations will adapt to percent max slope.
const Brake_Reaction_Time			= 2.5 #s
const Deceleration_Rate				= 11.2 #ft/s^2
const Design_Speed					= case Speed_Limit_in_MPH>=40:Speed_Limit_in_MPH+7.5 else: Speed_Limit_in_MPH # see Below- value chosen is on a much lower end. Please adjust as seen fit. Decision basis below.
# Source 8: TRB study on Design vs Speed limits: (Discussion informed by research 
#"Factors used to select design speed are functional classification, rural versus urban,
#and terrain (used by AASHTO); AASHTO Green Book procedure, legal speed limit,
#legal speed limit plus a value (e.g., 5 or 10 mph [8.1 to 16.1 km/h]), anticipated volume,
#anticipated operating speed, development, costs, and consistency (state DOTs);
#and anticipated operating speed and feedback loop (international practices)."
#...
#While the profession has a goal to set posted speed limits near the 85th percentile
#speed (and surveys say that 85th percentile speed is used to set speed limits), in reality,
#most sites are set at less than the measured 85th percentile speed. 
#NACTO has different design philosophy. 
# "To counteract these gruesome and unnecessary injuries and fatalities, cities should utilize 
#speed control mechanisms that influence behavior, lower speeds, and in turn, reduce injuries 
#and fatalities. Embracing a proactive design approach on new and existing streets with the goal 
#of reducing speeds may be the single most consequential intervention in reducing pedestrian injury and fatality."1"
#Thus they put forward: "Proactive Urban Street Design: Target Speed = Design Speed = Posted Speed"
#As a result of existing research relating to traffic speed and crash risk, and the fact that for the most part this
#rule is designed for urban streets, if the speed limit is greater than or equal to 40 mph (5 above NACTO suggested speed),
#The design speed is assumed to be Speed_Limit +7.5 other wise it is the Speed_Limit- a decision between the two philosophies. 
#This is a simple way to have "context sensitive" design speed, and more complex methods maybe considered down the line. 
const Brake_Reaction_Dist			= 1.47*Design_Speed*Brake_Reaction_Time
const Braking_Dist					= 1.075*((Design_Speed*Design_Speed)/Deceleration_Rate)# Time spent actually braking
const Stopping_Sight_Dist			= Brake_Reaction_Dist+Braking_Dist
##Unit Conversion- in terms of number of unit per meter,meter^2, or meter^3- convert by unit *conversion factor==new unit
const Feet							=3.28084 #per meter ^1
# const SquareFeet					=10.7639 #per meter ^2
# const Miles							=0.00062137 #per meter ^1
# const Inches						=39.3701 #per meter ^1
# const CubicFeet						=35.3147 #per meter ^3
#Thematic Constants
const Brightness="#d7d7d7"
const NACTOPedestrian="#FFFFFF"
const NACTOTransit="#AF4E57"
const NACTOAuto="#C3C2C0"
const NACTOStorage = "#CCCCCC"
const NACTOBike="#6AAA70"
const NACTOPlanting="#B5DC98"
const NACTOConflictZone="#F9ECB7" #Crosswalk in book
const NACTOBikeDark="#59995F"
const FehrAndPeersUberSharedMobility="#CAA8CD"
#Lane Constants:
const Default_Mix_Bus = case Transit_Lane=="Bus Lane":.0001 else: .075
const Default_Mix_Bike = case Bike_Lane_Type=="Sharrow" && _Maxof(Left_Bike_Lane_Width,Right_Bike_Lane_Width)==0:(.20*_BikeRank+.05) else: 0
const Default_Mix_Freight = case nLanesTotal >=4: abs((Speed_Limit_in_MPH)/5)/100.0 else: .01
const Default_Mix_Taxi = case Speed_Limit_in_MPH >= 30 && nLanesTotal >= 4: .15 else: .02
#####################
#Tree.Generated Rules		#
#####################
import Tree : "/ESRI.lib/rules/Plants/Plant_Loader.cga" # Taken from ESRI.lib and uses its assets. Keep this in mind when using rule. 
# import Fences: "/ESRI.lib/rules/Fences/Fence_On_Graph.cga"
#####################
#Text.Generated Rules		# - Uncomment out anything with Street_Text.X for functionality. 
#####################
#import Street_Text : "Street_Text.cga" #- Work in Progress

###################################################
# Initial attribute settings
# (to get a diversified default appeareance depending on initial shape, connection object attributes and randomness)
#
_Distribute_Right_Lanes =
	rint(Lane_Distribution*nLanesTotal)+ _Transit_Lane_Dist_Adj #The Transit Lane Distribution adjuster only is active if the bus lane is put on the right to correct the bias from rounding up when transit lanes are present
_getInitialLaneDistribution =
	case initialShape.startRule=="Roundabout": 1
	case (streetWidth/ Lane_Width )>=2.2	 : .5 
	case p(0.5)							   	 : 1
	else                                   	 : 0
_Initital_Transit_Lane_Sides=
	case Lane_Distribution==1:
		"Right"
	case Lane_Distribution==0:
		"Left"
	else:
		"Both"
	
_getInitialStop(connection,nLanes) =
	case _hasStop(connection) && (streetLength>20):
		case connection=="ROUNDABOUT": "right;right;right;right"
		else		 				 : "line only"
	else: "none"

_InititalSpeedLimit=
	case nLanesTotal>5:
		_Minof((nLanesTotal*10),75)
	else:
		35

_getInitialCrosswalk(connection) =
	case _hasStop(connection) && streetLength>10 && _PedRank>.5:
		"continental"
	case _hasStop(connection) && streetLength>10: 85%: "continental" 5%: "ladder custom" 5%: "transverse" else: "none"
	else: "none"

_getInitialGap(connection)=
	case _hasStop(connection): 
		2.4
	else:
		 -2
_getInitialCenterWidth = case oneWay || Center_Type=="None": 0 
					     case Center_Type=="Barrier":.98
					     case Center_Type=="Boulevard" || Center_Type=="Barrier & Shoulder": 10
					     case find(Center_Type,"Turn Lane",0)!=-1 || find(Center_Type,"Median",0)!=-1: Lane_Width+.1
					     else:PaintLineWidth*4
_PlantingWidth=
	case sidewalkSide=="Right":
		_Minof(_Maxof((sidewalkWidthRight*0.33),0.66),1.8)
	else:
		_Minof(_Maxof((sidewalkWidthLeft*0.33),0.66),1.8)

_ContiguousPlantingSwitch(Spacing_Width)=
	case Spacing_Width == 0: 0 else: 1
		

_ParkingWidth(ParkingType)				=
	case ParkingType=="None":
		0
	case find(ParkingType,"Parallel",0)!=-1:
		2.44 #Door zone should have another 1-1.5 ft iff parking is on inside
	else:
		6.7 # 22 ft
	
_ParkingLength(ParkingType)				=
	case ParkingType=="None":
		0
	case find(ParkingType,"Parallel",0)!=-1:
		6.7 # 22 ft
	else:
		2.6
	
_Allocate_Midpoint_Curbside(Allocation_Position)=
	case find(Allocation_Position,"Mid-Block",0)!=-1:
		1
	else:
		0
_Allocate_Farside_Curbside(Allocation_Position)=
	case find(Allocation_Position,"End Spaces",0)!=-1||find(Allocation_Position,"Far-side",0)!=-1:
		1
	else:
		0	
_Allocate_Nearside_Curbside(Allocation_Position)=
	case find(Allocation_Position,"End Spaces",0)!=-1||find(Allocation_Position,"Near-side",0)!=-1:
		1
	else:
		0	
			
_HasCurbsideManagement(ParkingType) =
    case find(ParkingType,"Curbside",0)!=-1:
    	1
    else:
    	0
 	
_Side_Sidewalk_Planting_Width(side) =
 	case side=="Right":
 		Right_Sidewalk_Planting_Width
 	else:
 		Left_Sidewalk_Planting_Width
_Side_Sidewalk_Furniture_Zone_Width(side) =
 	case side=="Right":
 		Right_Sidewalk_Furniture_Zone_Width
 	else:
 		Left_Sidewalk_Furniture_Zone_Width
_Sidewalk_BikeLane_Width(Dir)		=
	case Dir==0:
		Sidewalk_Right_Bike_Lane_Width
	else:
		Sidewalk_Left_Bike_Lane_Width
_Car_Angle(ParkingType)				=
	case find(ParkingType,"Parallel",0)!=-1:
		0
	case leftHandTraffic:
		295
	else:
		245
_Front_Parking_Spacing(Parking_Type) = 
case Front_Parking_Spacing!=0:
	Front_Parking_Spacing
else:
	case find(Parking_Type,"Parallel",0)!=-1:
		6
	case Parking_Type=="Angled Nose In":
		6
	case Parking_Type=="Angled Back In":
		6
	else:
		1							 	

_Rear_Parking_Spacing(Parking_Type)  =
case Rear_Parking_Spacing!=0:
	Rear_Parking_Spacing
else:
	case find(Parking_Type,"Parallel",0)!=-1:
		1
	case Parking_Type=="Angled Nose In":
		3
	case Parking_Type=="Angled Back In":
		3
	else:
		1	
###################################################
# Internal utilities
#
#Street Length and Lanes
@Hidden @Order(1) @Range(min=0,max=30)
attr streetWidth 				= geometry.dv(0,unitSpace)				# REALWORLD-distance in V-direction corresponds to width of street (in case the geometry does not contain rounded entry geometry)
@Hidden @Order(2) @Range(min=0,max=30)
attr Main_streetWidth			=streetWidth-(_LeftSplitSum+_RightSplitSum+_centerWidth+_Transit_Lane_Widths) 
@Hidden @Order(3) @Range(min=1,max=6)
attr laneWidth 					= 3.5 # note that TEXTURE-distance in V-direction corresponds to number of lanes (as generated by CityEngine)

const streetLength	= geometry.du(0,unitSpace)				# REALWORLD-distance in U-direction corresponds to length of street
const nLanesTotal	= case rint(Main_streetWidth/Lane_Width )>0:floor(Main_streetWidth/ Lane_Width ) case floor(Main_streetWidth/ Lane_Width )<=0:0 else: 1	
const nLanesLeft	= floor(nLanesTotal- _Distribute_Right_Lanes )
const RealLaneTotal	= (nLanesTotal)+(_Transit_Lane_Count)
const DirLaneTotal	= (nLanesTotal/2)+(_Transit_Lane_Count/2)
#######################################################################################################################
#Directional
const rightHandTraffic	 	= Traffic_Direction =="right-hand"
const leftHandTraffic	  	= !rightHandTraffic
const oneWay			 	= Lane_Distribution <=0 || Lane_Distribution>=1 #Used to be:_Distribute_Right_Lanes <=0 || nLanesLeft<=0
const DirectionalFlip	 	= case rightHandTraffic:1 else:-1 				# This is used to mirror UVs when right hand traffic is false
const DirectionalRotation	= case rightHandTraffic:0 else:180

#Other
const _oneWayForward 		   = (rightHandTraffic && Lane_Distribution>=1) || (leftHandTraffic && Lane_Distribution>=1)	# in direction of graph segment?
const _oneWayReverse 		   = oneWay && !_oneWayForward
const _stopBegin 			   = case Stop_Begin =="none" || _oneWayForward: 0 else: 1
const _stopEnd 				   = case Stop_End =="none"   || _oneWayReverse: 0 else: 1
const _neighborBegin		   = case Stop_Begin !="none" || _hasStop(connectionStart):1 else: 0
const _neighborEnd			   = case Stop_End !="none" || _hasStop(connectionEnd):1 else: 0
const _crosswalkWidth		   = case _Maxof(sidewalkWidthLeft,sidewalkWidthRight)==0:3 else:(_Maxof(sidewalkWidthLeft,sidewalkWidthRight)+ 0.1524)//changed to match width of largest sidewalk + 0.1524 (6 inches), if 0 default is 2. 
const _crosswalkBeginWidth	   = case Crosswalk_Begin =="none": 0 else: (Crosswalk_Width)
const _crosswalkEndWidth 	   = case Crosswalk_End =="none"  : 0 else: (Crosswalk_Width)
const _centerWidth	 		   = case oneWay || Center_Type=="None": 0 
							     case Center_Type != "None" && find(Center_Type,"Centerline",0)==-1: Center_Width
							     else:PaintLineWidth*4				  
const _Bike_Paint_Adjuster	   = case Bike_Paint_Line_Sides=="Right"||Bike_Paint_Line_Sides=="None":1 else:2
const _EmptySpace			   = (streetWidth-(nLanesTotal* Lane_Width +_LeftSplitSum +_RightSplitSum+_centerWidth+_Transit_Lane_Widths))/2  # is Per Side-so combined is this *2
const _AdjEmptySpace		   = (_EmptySpace*2)
const _Actual_Lane_Width	   = case _Actual_Space_Management!= "Best Fit": Lane_Width else:((Lane_Width+(_AdjEmptySpace/nLanesTotal))-.01)
const _Actual_Space_Management = case nLanesTotal==0:"Exact" else: Space_Management
#Transit Lane Constants
const _Transit_Lane_Widths	= case Transit_Lane=="None":0 case Transit_Lane_Sides=="Both": 2*Transit_Lane_Width else:Transit_Lane_Width# Is the combined width of transit lanes not in Center					  
const _Rt_Transit_Lane_Width= case Transit_Lane=="None":0 case Transit_Lane_Sides=="Right" || Transit_Lane_Sides=="Both":Transit_Lane_Width else: 0
const _Lt_Transit_Lane_Width= case Transit_Lane=="None":0 case Transit_Lane_Sides=="Left" || Transit_Lane_Sides=="Both":Transit_Lane_Width else: 0 #case _Actual_Space_Management=="Best Fit":0
const _Transit_Lane_Dist_Adj= case Transit_Lane=="None":0 case oneWay:0 case Transit_Lane_Sides=="Left":1 else:0 #all this constant does is adjust the lane distribution so that transit lanes do not overly interfere with lane distribution calculations for right transit lanes (we want it to count as a "Lane")
const _Transit_Lane_Count	= case Transit_Lane=="None":0 case Transit_Lane_Sides=="Both":2 else:1
const _Rt_Transit_Lane_Count= case Transit_Lane=="None"||Transit_Lane=="Left":0 else:1
const _Lt_Transit_Lane_Count= case Transit_Lane=="None"||Transit_Lane=="Right":0 else:1
#To keep the units exact, we do not distribute the lanes, we fill empty space with concrete (drainage). 

# const _through = connectionEnd=="STREET" || connectionStart=="STREET" || connectionEnd=="JUNCTION" || connectionStart=="JUNCTION" || connectionEnd=="FREEWAY" || connectionStart=="FREEWAY"
# Vegetation and Hardscape costs -------------------------------
const TreeCostAverage = 750 
# const GrassSurfaceCostAverage = 10	# In square meters
# const HardscapePaverCost = 25		# In square meters

###################################################
#Functions										  #
###################################################
#Split Based and Misc Functions

_RightSplitSum=
	Street_Right_Bike_Lane_Width + Right_Parking_Width + Right_Buffer_Width				#Generates right road side features that need to be fractions of lanewidths
	
_LeftSplitSum=
	Street_Left_Bike_Lane_Width + Left_Parking_Width + Left_Buffer_Width				#Generates right road side features that need to be fractions of lanewidths

_Bike_Box_Gap(street_side)=
	case street_side=="Begin" && Left_Bike_Box_Bool:Bike_Box_Length/2
	case street_side=="End" && Right_Bike_Box_Bool:Bike_Box_Length/2
	else:0	

_MaxSplitSum=
	case _RightSplitSum>=_LeftSplitSum:
		_RightSplitSum
	else:
		_LeftSplitSum
_Orientation_Modified_SplitSum=
	_MaxSplitSum-_BikeSense_Modifier
_IsCycleTrackBuffer=
	case find(Buffer_Type,"Curb Buffer",0)!=-1 || find(Buffer_Type,"Cycle Track",0)!=-1:
		"true"
	else:
		"false"
_IsCycleTrack=
	case Parking_Protection_Bool && _MaxParkingSum>1 && (Street_Right_Bike_Lane_Width>0 || Street_Left_Bike_Lane_Width>0)&&_Orientation_Modified_SplitSum>=4.572:#Parking Scenario
		true
	case bool(_IsCycleTrackBuffer) && (Street_Right_Bike_Lane_Width>0 || Street_Left_Bike_Lane_Width>0) &&_MaxParkingSum<=1 && _Orientation_Modified_SplitSum>=1.8288: #Plain Buffer
		true
	case find(Bike_Lane_Type,"Sidewalk",0)!=-1 && (Sidewalk_Right_Bike_Lane_Width>0||Sidewalk_Left_Bike_Lane_Width>0):#Sidewalk protected facility
		true
	else:
		false
_MaxParkingSum=
	case _MaxSplitSum==_RightSplitSum:
		Right_Parking_Width
	else:
		Left_Parking_Width

_MaxBufferSum=
	case _MaxSplitSum==_RightSplitSum:
		Right_Buffer_Width
	else:
		Left_Buffer_Width

_Transit_Lane_Width_Switch(dir,Location)=	
	case Transit_Lane=="None":
		0
	case dir==0 && (Transit_Lane_Sides=="Both" || Transit_Lane_Sides=="Right"):
		case Location==Transit_Lane_Position: # Each call of this function has a string defining its location.
			Transit_Lane_Width
		else:
			0
	case dir==2 && (Transit_Lane_Sides=="Both" || Transit_Lane_Sides=="Left"):
		case Location==Transit_Lane_Position: # Each call of this function has a string defining its location.
			Transit_Lane_Width
		else:
			0
	else:
		0


#Stop Tex/Approach/Neighbor Detection Functions
_hasStop(neighbor) 	= neighbor=="CROSSING" || neighbor=="ROUNDABOUT" || neighbor=="JUNCTION_ENTRY"||neighbor=="JUNCTION"||neighbor=="DEAD_END"
_hasStopSideSwitch(dir)= case dir==0: _neighborEnd else: _neighborBegin		
_stopTex(stopType,lanenumber,lanestotal)			= #TODO: Add more lane options- D.J.Wasserman
					  case find(stopType,";",0)!=-1:
					  	    _stopListTex(stopType,lanenumber)
					  case stopType == "with stop marking"	  : 
					  		case rightHandTraffic: "_stop_word" else: "_stop_word_mirrored"
					  case stopType == "arrows on all lanes"  : 
					  		"_stop_arrows_all_"+str((case lanenumber+1>5:5 else:lanenumber+1))
					  case stopType == "arrows on side lanes" : 
					  		"_stop_arrows_sides_"+str((case lanenumber+1==1:1 case lanenumber+1==lanestotal:4 else:3))
					  case stopType == "arrows for right turn":
					  		 "_stop_arrows_right_"+str((case lanenumber+1>4:4 else:lanenumber+1))
					  case stopType == "arrows for left turn" && lanenumber+1==lanestotal :
					  		 "_stop_arrows_all_" + str(5)
					  else: #Any time you see more case logic for the first trigger, it is a result of trying to work in the current framework
					  		 "_stop_strip"
_stopListTex(stopType,lanenumber)		=
	case lanenumber >= listSize(stopType):
		_arrowChoice(listLast(stopType))
	else:
		_arrowChoice(listItem(stopType,lanenumber))
		
_arrowChoice(stopCode) 								=
	case stopCode =="stop":
		case rightHandTraffic: "_stop_word" else: "_stop_word_mirrored"			  
	case stopCode =="right":
		"_stop_arrows_all_1"#right
	case stopCode =="through-right":
		"_stop_arrows_all_2"#through-right
	case stopCode =="through":
		"_stop_arrows_all_3"#through
	case stopCode =="through-left":
		"_stop_arrows_all_4"#through-left	
	case stopCode =="left":
		"_stop_arrows_all_5"#left
	case stopCode =="all":
		"_stop_arrows_all_6"#all
	case stopCode =="both":
		"_stop_arrows_all_7"#both
	else:
		"_stop_strip"
_dropNones(stopType,lanestotal) 								=
	case lanestotal<listSize(stopType) && find(stopType,"none",0)!=-1:
		_dropNones(listRemove(stopType,"none"),lanestotal)
	else:
		stopType	
		
_stopSten(stopType,lanenumber,lanestotal)			= #TODO: Add more lane options- D.J.Wasserman
	case find(stopType,";",0)!=-1:
  	    _stopListStencil(stopType,lanenumber)
  	case stopType == "with stop marking"	  : 
  		_stopListStencil("stop;",lanenumber)
    case stopType == "arrows on all lanes"  : 
  		_stopListStencil("right;through-right;through;through-left;left",lanenumber)
    case stopType == "arrows on side lanes" :
  		_stopListStencil(_dropNones("right;none;none;none;none;none;none;left",lanestotal),lanenumber)
    case stopType == "arrows for right turn":
  		_stopListStencil(_dropNones("right;right;none;none",lanestotal),lanenumber)
    case stopType == "arrows for left turn" && lanenumber+1==lanestotal :
  		_stopListStencil(_dropNones("none;none;none;none;none;none;none;none;left;left",lanestotal),lanenumber)
    else: #Any time you see more case logic for the first trigger, it is a result of trying to work in the current framework
  		 _stopListStencil("none;",lanenumber)

_stopListStencil(stopType,lanenumber)		=
	case lanenumber >= listSize(stopType):
		_arrowStencilChoice(listLast(stopType))
	else:
		_arrowStencilChoice(listItem(stopType,lanenumber))
		
_arrowStencilChoice(stopCode) 								=
	case stopCode =="stop":
		case rightHandTraffic: "Stop_Symbol.obj" else:"Stop_Symbol_Mirrored.obj"	  
	case stopCode =="right":
		"Right_Arrow.obj"#right
	case stopCode =="through-right":
		"Right-Through_Arrow.obj"#through-right
	case stopCode =="through":
		"Through_Arrow.obj"#through
	case stopCode =="through-left":
		"Left-Through_Arrow.obj"#through-left	
	case stopCode =="left":
		"Left_Arrow.obj"#left
	case stopCode =="all":
		"All_Arrow.obj"#all
	case stopCode =="both":
		"Both_Arrow.obj"#both
	else:
		"Nothing.obj"		
_LastLaneSwitch(lanenumber,lanestotal)=
	case lanenumber==lanestotal-1:
		0
	else:
		1	

#Paintcontrol and Bus Furniture functions

_TextureDimensionByUsage(Usage)=
	case Usage =="Auto":Asphalt_Tile_Size
	else: Sidewalk_Tile_Size
	
_PaintLineControl(side,Control_String)=
	case side=="Left":
		case Control_String=="Both":	1
		case Control_String=="Right":	0
		case Control_String=="Left":	1
		else: 							0
	else:
		case Control_String=="Both":	1
		case Control_String=="Right":	1
		case Control_String=="Left":	0
		else: 							0
		
_Bus_Furniture_Base(Center_Section,Location,Facing_Side)=
	case Median_Bus_Stop=="None":#2
		0
	case Location=="Far and Near Side" && Median_Bus_Stop_Location!="Mid-Block":
		case Facing_Side==0:
			case Median_Bus_Stop=="Left"||Median_Bus_Stop=="Both":
				BusStop_Length
			else:
				0
		else:
			case Median_Bus_Stop=="Right"||Median_Bus_Stop=="Both":
				BusStop_Length
			else:
				0	
	case Median_Bus_Stop_Location=="Mid-Block" && Facing_Side==1:
		BusStop_Length
		#This works for the Mid_Block Section, right and left are handled in another 
		#function (below) for mid-block because they occupy the same shape. 
	case Facing_Side==0:#2
		case Median_Bus_Stop=="Right"||Median_Bus_Stop=="Both":#3
			case Median_Bus_Stop_Location==Location:#4
				BusStop_Length
			else:#4
				0
		else:0#3
	case Facing_Side==2:#2
		case Median_Bus_Stop=="Left" ||Median_Bus_Stop=="Both":#3
			case Median_Bus_Stop_Location==Location:#4
				BusStop_Length
			else:#4
				0
		else:0#3
	else:#2
		0
_Bus_Sidewalk_Base(Location)=
	case Sidewalk_Bus_Stop=="None":
		0
	case sidewalkSide==Sidewalk_Bus_Stop || Sidewalk_Bus_Stop=="Both":
			case Sidewalk_Bus_Stop_Location==Location:
				BusStop_Length
			else:
				0
	else:#
		0
_Median_Midblock_Switch(Side,Pad_Type)=
	case Pad_Type=="WalkWay":
		case Median_Bus_Stop=="Both":
			0
		case Median_Bus_Stop=="Right":
			case Side==0:
				0
			else:
				.5
		case Median_Bus_Stop=="Left":
			case Side==2:
				0
			else:
				.5
		else: 
			0
	else:
		case Median_Bus_Stop=="Both":
			.5
		case Median_Bus_Stop=="Right":
			case Side==0:
				.5
			else:
				0
		case Median_Bus_Stop=="Left":
			case Side==2:
				.5
			else:
				0
		else: 
			0
_Bus_Alloc(Location)					=.7#Allows user to adjust by location if customized. 

_Bike_Rack_Alloc(Location)				=
			case Location== "Median" || Location=="Boulevard":
					case Median_Bike_Rack_Bool: .2
					else: 0
			else:
					case Sidewalk_Bike_Rack_Bool:.2
					else: 0
					
_WayFinder_Alloc(Location)				=
			case Location== "Median" || Location=="Boulevard":
					case Median_Way_Finder_Bool: .1
					else: 0
			else:
					case Sidewalk_Way_Finder_Bool:.1
					else: 0
					
_Sidewalk_CrossStop_Gap(Dir,Begin)= #Limits the amount of gap to 5.4 meters (3 m sidewalk+2.4 crosswalkgap) Keep trees out of crosswalk/clear view for drivers at intersections.
	case Dir==0:
		case Begin=="Begin":
			_Minof(_crosswalkEndWidth+ End_Crosswalk_To_Stop_Bar,Max_Sidewalk_Gap)  
		else: 
			_Minof(_crosswalkBeginWidth+ Begin_Crosswalk_To_Stop_Bar,Max_Sidewalk_Gap)
	else:
		case Begin=="Begin":
			_Minof(_crosswalkBeginWidth+ Begin_Crosswalk_To_Stop_Bar,Max_Sidewalk_Gap) 
		else: 
			_Minof(_crosswalkEndWidth+ End_Crosswalk_To_Stop_Bar,Max_Sidewalk_Gap)

_uScale	= case geometry.du(0,unitSpace)>10: 1	
		  case geometry.du(0,unitSpace)>4 : 1/2	# in case the street is too short, we only use half of the texture
		  else				  			  : 1/6	# if even shorter, we use only the start of the texture (i.e. centerline only)

#Parking Functions:
_ParParkedFacing(Side) = case Side=="Right":# This makes the park car facing adapt to whether the street is one way etc. 
							case Lane_Distribution<=0:
							2
							case Lane_Distribution>=1:
							0
							else:
							0
						 else: #Only other option is Left
						 	case Lane_Distribution<=0:
							2
							case Lane_Distribution>=1:
							0
							else:
							2
_Parking_Cap_Angle(Side,Position) =
	case Position == "End":
		case _ParParkedFacing(Side) == 0:
			case Side =="Right":
				270+ (case rightHandTraffic: 0  else: 90)
			else: 
				180+ (case rightHandTraffic: 0  else: 270)
		else: 
			case Side =="Right":
				0+ (case rightHandTraffic: 0  else: 270)
			else: 
				90+ (case rightHandTraffic: 0  else: 90)
	case Position == "Begin":
		case _ParParkedFacing(Side) == 0:
			case Side =="Right":
				0+ (case rightHandTraffic: 0  else: 270)
			else:
				90+ (case rightHandTraffic: 0  else: 90)
		else:
			case Side =="Right":
				270+ (case rightHandTraffic: 0  else: 90)
			else:
				180+ (case rightHandTraffic: 0  else: 270)
	else:
		case Side=="Right":
			0
		else: 
			180
#Misc Functions	
#_isEven(number) = (rint(abs(number))%2) == 0   #Make number positive, round to nearest integer just in case of 6 being 5.99999999999999, or 6.000000000000001.
#_isOdd(number) = !_isEven(number)	
#_targetReturn(target,input,return)=case input==target: return else:		0	
_tooShort(length,goal_len)= 
	case length<goal_len: 0
	else: 1
#_round(num,sig_fig)=
#	rint(num*pow(10,sig_fig))/pow(10,sig_fig)	
_Maxof(num1,num2)= #Finds the max of two numbers
	case num1>=num2:
		num1
	else:
		num2
_Minof(num1,num2)= #Finds the min of two numbers
	case num1<=num2:
		num1
	else:
		num2
_DeviateValue(value,percent_deviation)= 
    value + (value * rand(-abs(percent_deviation),abs(percent_deviation)))

################################################
#Thematic Functions
const SemanticSegs="car;pedestrian;bus;planting_area;bike_lane;truck;parking_lane;bike_buffer;lamp;hov_lane;centerline;median;center_turn_lane;asphalt;bus_lane;drive_lane;stop_bar;crosswalk;sidewalk;bus_pull_in;passenger_loading;freight_loading;bike_parking;traffic_light;vegetation;bicyclist;"
const SemanticSegsSize = listSize(SemanticSegs)
_ThematicRouter(Usage,LabelID)	=
	case Display_Thematics == "Semantic":
		_SemanticClassifier(LabelID)
	case Display_Thematics=="Usage"||Display_Thematics=="All Mode Preference"||count(Display_Thematics,"Highlight")>0: 
	#Please construct your own usage zones if the current ones are not sufficient-Colors based on NACTO illustrations
		_ModeClassifier(Usage)
	else:
		Thematics #Attribute that diverts to _Thematic
		
_ThematicRouter (Usage)	=
	_ThematicRouter(Usage,"asphalt")

_ColorByLabel(LabelID,LabelList,ListSize,colorType)=
	colorRamp(colorType,float(listIndex(LabelList,LabelID)+1)/float(ListSize))#Plus 1 because a null index find is -1 so +1 for 

_SemanticClassifier(LabelID)=
	_ColorByLabel(LabelID,SemanticSegs,SemanticSegsSize,"spectrum")

_Construct_PBR_Path(color_map_path,type) = 
	case type == "col":
		color_map_path
	case type == "norm":
		replace(color_map_path,"_Color","_Normal")
	case type == "disp":
		replace(color_map_path,"_Color.jpg","_Displacement.png")
	case type == "roug":
		replace(color_map_path,"_Color","_Roughness")
	case type == "aocc":
		replace(color_map_path,"_Color","_AmbientOcclusion")
	case type == "spec":
		replace(color_map_path,"_Color","_Metallic")
	case type == "meta":
		replace(color_map_path,"_Color","_Specularity")
	else:
		print("No correct type specified for path.")
			
_ModeClassifier(Usage)	=
	case Usage=="Shared Mobility":
	_SharedMobilityThematics(FehrAndPeersUberSharedMobility)
	case Usage=="Pedestrian":
	_PedestrianThematic(NACTOPedestrian)
	case Usage=="Conflict Zones":
	_ConflictZoneThematic(NACTOConflictZone)
	case Usage=="Bikeways":
	_BikewaysThematic(NACTOBike)
	case Usage=="Auto":
	_AutoThematic(NACTOAuto)
	case Usage=="Storage":
	_AutoThematic(NACTOStorage)
	case Usage=="Transit":
	_TransitThematic(NACTOTransit)
	case Usage=="Plantings":
	_PlantingThematic(NACTOPlanting)
	else:
		"#000000"

_SharedMobilityThematics(color) = 
	case Display_Thematics=="Usage":
		color
	case Display_Thematics=="Shared Mobility Highlight":
		Solid_Color
	case Display_Thematics=="All Mode Preference":
		getHexColorString(1-(_BikeRank+_PedRank+_TransitRank)/3,(_BikeRank+_PedRank+_TransitRank)/3,0)
	else:
		Secondary_Solid_Color	
_PedestrianThematic(color)=
	case Display_Thematics=="Usage":
		color
	case Display_Thematics=="Pedestrian Highlight":
		Solid_Color
	case Display_Thematics=="All Mode Preference":
		getHexColorString(1-_PedRank,_PedRank,0)
	else:
		Secondary_Solid_Color

_TransitThematic(color)=
	case Display_Thematics=="Usage":
		color
	case Display_Thematics=="Transit Highlight":
		Solid_Color
	case Display_Thematics=="All Mode Preference":
		getHexColorString(1-_TransitRank,_TransitRank,0)
	else:
		Secondary_Solid_Color

_BikewaysThematic(color)=
	case Display_Thematics=="Usage":
		color
	case Display_Thematics=="Bicycle Highlight":
		Solid_Color
	case Display_Thematics=="All Mode Preference":
		getHexColorString(1-_BikeRank,_BikeRank,0)
	else:
		Secondary_Solid_Color
_AutoThematic(color)=
	case Display_Thematics=="Usage":
		color
	case Display_Thematics=="Auto Highlight":
		Solid_Color
	case Display_Thematics=="All Mode Preference":
		getHexColorString(1-_AutoRank,_AutoRank,0)
	else:
		Secondary_Solid_Color

_PlantingThematic(color)=
	case Display_Thematics=="Usage":
		color
	case Display_Thematics=="Planting Highlight":
		color # TODO - Fix Compile Error Here
	case Display_Thematics=="All Mode Preference":
		getHexColorString(1-_PedRank,_PedRank,0)
	else:
		Secondary_Solid_Color

_ConflictZoneThematic(color)=
	case Display_Thematics=="Usage":
		color
	case Display_Thematics=="All Mode Preference":
		getHexColorString(1-_PedRank,_PedRank,0)
	else:
		Secondary_Solid_Color 	
		
_GeneralThematic				=
	case Display_Thematics=="Thematics Off":
		Brightness # Started as: "#d7d7d7" as constant
	case Display_Thematics=="Solid Color":
		Solid_Color
	case Display_Thematics=="Bike Preference":
		getHexColorString(1-_BikeRank, _BikeRank, 0)
	case Display_Thematics=="Auto Preference":
		getHexColorString(1-_AutoRank,_AutoRank,0)
	case Display_Thematics=="Transit Preference":
		getHexColorString(1-_TransitRank,_TransitRank,0)
	case Display_Thematics=="Pedestrian Preference":
		getHexColorString(1-_PedRank,_PedRank,0)
	case peakRunoffDisplayOn:
		"#FFFFFF"
	case Display_Thematics=="Flood Scenario":
		case  scope.elevation<=Base_Flood_Elevation:
			"#0a39FF"
		else:
			Brightness
	else:
		Brightness

_BikeSense_Modifier			=#changes combined "bike protection" width based orientation-with splitsum creates distance from through lane
	case !Buffer_Protection_Bool && Parking_Protection_Bool :
		(_MaxBufferSum)
	case Buffer_Protection_Bool && ! Parking_Protection_Bool :
		0
	case Buffer_Protection_Bool && Parking_Protection_Bool :
		0
	else:
		(_MaxParkingSum + _MaxBufferSum)
###########################
#Preference Metrics Rankings- Create your own or edit the existing
###########################
#Transit_Lane_Count adjusts the lane total based on the presence of one (+1) or two (+2) bus lanes. Only matters for reporting. 
_BikeRank				=#Adapted from MTI Report 11-19 # Does not take into account Boulevard Cycle Paths
	case _IsCycleTrack:
		1
	case !Parking_Protection_Bool && _MaxParkingSum>1 && (Street_Right_Bike_Lane_Width>0 || Street_Left_Bike_Lane_Width>0) :
		case floor((DirLaneTotal))<=1 &&  Speed_Limit_in_MPH<=25 && Level_of_Blockage=="Rare" &&_Orientation_Modified_SplitSum>=4.572:
			1 #LTS 1- 
		case (Speed_Limit_in_MPH<25)||(floor((DirLaneTotal))<=2 && Speed_Limit_in_MPH<=30 && Level_of_Blockage=="Rare" &&_Orientation_Modified_SplitSum>=4.2672):
			.66 #LTS 2
		case Speed_Limit_in_MPH<=35 &&_Orientation_Modified_SplitSum>=4.1148:
			.33 #LTS 3
		else:
			0 #LTS 4
			
			
	case (Street_Right_Bike_Lane_Width>0 || Street_Left_Bike_Lane_Width>0) &&_MaxParkingSum<=1: # Bike Lanes not along parking lane
		case floor((DirLaneTotal))<=1 &&  Speed_Limit_in_MPH<=30 && Level_of_Blockage=="Rare" && _Orientation_Modified_SplitSum>=1.8288:
			1 #LTS 1
		case (Speed_Limit_in_MPH<25)|| (Speed_Limit_in_MPH<=35  &&(floor((DirLaneTotal))<=(case find(Center_Type,"Median",0)!=-1:2 else: 1)&& Level_of_Blockage=="Rare" && _Orientation_Modified_SplitSum>0)):
			.66 #LTS 2-speed limit has no effect so it jumps to next highest speed limit
		case (Speed_Limit_in_MPH<=35 && _Orientation_Modified_SplitSum>0):
			.33 #LTS 3
		else:
			0 #LTS 4
	else:
		case (RealLaneTotal<=3 && Speed_Limit_in_MPH<=25):
			1 #LTS 1
		case (RealLaneTotal<=3 && Speed_Limit_in_MPH<=30):
			.66 #LTS 2
		case (RealLaneTotal<=4 && Speed_Limit_in_MPH<=30):
		 	.33 #LTS 3
		else:
		 	0 #LTS 4
_PedRank				=#Rule creator criteria-a road with low speed limits and less lanes is good OR a road with good separation between cars and pedestrians and a wider sidewalk is better
	 	case (rint(DirLaneTotal)<=1 && Speed_Limit_in_MPH<=20 && _centerWidth<=7) || (_MaxSplitSum>=2.43 && _Maxof(sidewalkWidthLeft,sidewalkWidthRight)>=3.3 && Speed_Limit_in_MPH<=35):
	 		1 
	 	case  (rint(DirLaneTotal)<=2 && Speed_Limit_in_MPH<=25) || (_MaxSplitSum>=2.2 && _Maxof(sidewalkWidthLeft,sidewalkWidthRight)>=2.5 && Speed_Limit_in_MPH<=35):
	 		.8
	 	case  (rint(DirLaneTotal)<=2 && Speed_Limit_in_MPH<=30) || (_MaxSplitSum>=1.2 && _Maxof(sidewalkWidthLeft,sidewalkWidthRight)>=1.8 && Speed_Limit_in_MPH<=40):
	 		.6
	 	case  (rint(DirLaneTotal)<=3 && Speed_Limit_in_MPH<=35) &&(_Maxof(sidewalkWidthLeft,sidewalkWidthRight)>=1.524):
	 		.4
	 	case  (rint((DirLaneTotal))<=4 && Speed_Limit_in_MPH<=40) && (_Maxof(sidewalkWidthLeft,sidewalkWidthRight)>=1.2191):
	 		.2
	 	else:
	 		0
_AutoRank				= #Criteria is simply based on lanewidths, on-street parking presence,lane number (does it enable passing?), and reduction of turning conflicts (is there a center turn lane). The top rank is practically high way conditions with a shoulder (shoulders reduce driver stress about accidents /reduce variance is highway performance by providing vehicle storage). 
		case ((rint(DirLaneTotal))>=3 && Lane_Width >=3.6576 && _Maxof(Left_Parking_Width,Right_Parking_Width)==0) || (findFirst(Center_Type,"Turn Lane")!=-1 && (rint((nLanesTotal/2) +_Transit_Lane_Count/2))>=2 && Lane_Width >=3.3528 && _Maxof(Left_Parking_Width,Right_Parking_Width)==0)&& (Buffer_Type=="Shoulder" || Center_Type=="Barrier & Shoulder") :
			1
		case ((rint(DirLaneTotal))>=2 && Lane_Width >=3.6576 && _Maxof(Left_Parking_Width,Right_Parking_Width)==0) || (findFirst(Center_Type,"Turn Lane")!=-1 && (rint((nLanesTotal/2) +_Transit_Lane_Count/2))>=2 && Lane_Width >=3.3528 && _Maxof(Left_Parking_Width,Right_Parking_Width)==0):
			.8
		case ((rint(DirLaneTotal))>=2 && Lane_Width >=3.358  && (Left_Parking_Width==0 || Right_Parking_Width==0)) || (findFirst(Center_Type,"Turn Lane")!=-1 && (rint((nLanesTotal/2) +_Transit_Lane_Count/2))>=1 && Lane_Width >=3.048 && _Maxof(Left_Parking_Width,Right_Parking_Width)==0):
			.6
		case ((rint(DirLaneTotal))>=1 && Lane_Width >=3.048  && (Left_Parking_Width==0 || Right_Parking_Width==0)) || (findFirst(Center_Type,"Turn Lane")!=-1 && (rint((nLanesTotal/2) + _Transit_Lane_Count/2))>=1 && Lane_Width >=3.048 && (Left_Parking_Width==0 ||Right_Parking_Width==0)):
			.4
		case ((rint(DirLaneTotal))>=1 && Lane_Width >=3.048)  || (findFirst(Center_Type,"Turn Lane")!=-1 && (rint((nLanesTotal/2) +_Transit_Lane_Count/2))>=1 && Lane_Width >=3.048):
			.2
		else:
			0

_TransitRank			= #Criteria based on whether or not there are, proper lane widths, transit dedicated lanes, painted red is better,boulevard transit lanes are best performing (no ability to get into transit lane)-HOV lane is treated a like a preferential bus lane-essentially ranks a roads ability to provide preferential service
		case Bus_Lane_Color== "red" && (findFirst(Transit_Lane,"Bus")!=-1||findFirst(Transit_Lane,"Light Rail")!=-1) && Transit_Lane_Width >=3.35 && (rint((nLanesTotal/2))+(_Transit_Lane_Count/2))<=2 && Transit_Lane_Sides =="Both" ||Center_Type=="Boulevard" && Boulevard_Configuration=="Bus Lanes" && Boulevard_Inside_Width>=6.5:
			1
		case Bus_Lane_Color== "red" && findFirst(Transit_Lane,"Bus")!=-1:
			.8
		case Transit_Lane !="None" && Lane_Width >=3.048 && (rint(((nLanesTotal/2))+(_Transit_Lane_Count/2)))<=3:
			.6
		case Transit_Lane !="None" && Lane_Width >=3.048:
			.4
		case rint(DirLaneTotal)<=2:
			.2
		else:
			0
#This is the code for the decimal number to hex converter, and it is used to create thematics based on a numerical
#critera that is normalized on a 0 to 1 scale. 
#Number 0 to 1 decimal to Hexstring converter code from Chris Wilkins
#Hex string and 256 values from normal values (0 to 1).

convertNormalTo256(normalValue) = rint(normalValue * 255)
getSixteensDigitFrom256(value256) = floor(value256 / 16)
getOnesDigitFrom256(value256) = value256 - (getSixteensDigitFrom256(value256) * 16)
# Just 
# getHex256(sixteens, ones) = (sixteens * 16) + ones
getHex256String(sixteens, ones) = hexString(sixteens) + hexString(ones)

getHexColorString(normalR, normalG, normalB) = 
	"#" + 
	getHex256String(
		getSixteensDigitFrom256(convertNormalTo256(normalR))
		,
		getOnesDigitFrom256(convertNormalTo256(normalR))
	)
	+
	getHex256String(
		getSixteensDigitFrom256(convertNormalTo256(normalG))
		,
		getOnesDigitFrom256(convertNormalTo256(normalG))
	)
	+
	getHex256String(
		getSixteensDigitFrom256(convertNormalTo256(normalB))
		,
		getOnesDigitFrom256(convertNormalTo256(normalB))
	)

hexString(hexValue) = 
	case hexValue == 0 : "0"
	case hexValue == 1 : "1"
	case hexValue == 2 : "2"
	case hexValue == 3 : "3"
	case hexValue == 4 : "4"
	case hexValue == 5 : "5"
	case hexValue == 6 : "6"
	case hexValue == 7 : "7"
	case hexValue == 8 : "8"
	case hexValue == 9 : "9"
	case hexValue == 10 : "A"
	case hexValue == 11 : "B"
	case hexValue == 12 : "C"
	case hexValue == 13 : "D"
	case hexValue == 14 : "E"
	case hexValue == 15 : "E"
	case hexValue == 16 : "F"
	else : "" #Error.
	
	
################################
# Normalization to 0 to 1 range.

# const NormalMin = 0
# const NormalMax = 1
#Use the following functions if you had data that can be fed into the _Rank functions:
#dataValueAdj(dataValueOriginal,Max_Data_Value, Min_Data_Value) = 
#	case dataValueOriginal < Min_Data_Value: Min_Data_Value
#	case dataValueOriginal > Max_Data_Value: Max_Data_Value
#	else: dataValueOriginal

#normalValue(dataValue,Max_Data_Value,Min_Data_Value) = 
#	NormalMin + (((dataValueAdj(dataValue,Max_Data_Value,Min_Data_Value) - Min_Data_Value ) 
#	* ( NormalMax - NormalMin ))
#	/ ( Max_Data_Value - Min_Data_Value))
###################################################
###################################################
##
##  RULES
##
###################################################
# Street Lane Texturing
#
#setupProjection(2,scope.xz,2,2 )
#set(material.dirtmap,LanesFolder+"/dirtmap.1.512x512.jpg")
#projectUV(2)

# split away the crosswalks at the beginning (if any) using the special UVSET 1
@StartRule
Street -->	#DeleteUV if texturing is off
	set(material.name,"Road_Bed")
	Initial_Street_Settings
	
Initial_Street_Settings-->
	case Specularity==1 && Transparency==0:
		Short_Long_Street
	else:
		Short_Long_Street_Altered
		
Short_Long_Street_Altered-->
	case Transparency>0 && Specularity==1:
		set(material.opacity,1-Transparency)
		Short_Long_Street
	else:
		set(material.specular.g,Specularity)
		set(material.specular.b,Specularity)
		set(material.specular.r,Specularity)
		Short_Long_Street
	
Short_Long_Street-->
	case _uScale==1: #IF the Street is long enough continue normally. 
		Long_Street
	
 	else: #If the street is too short no stop lines, no bike boxes. 
 		Short_Street	

Long_Street-->
	ReportMultimodalMetrics(reportingOn)
	BridgeMain
	split(u,uvSpace,1){_crosswalkBeginWidth/10: Asphalt("Auto","asphalt")
					  | _crosswalkBeginWidth  : Crosswalk( Crosswalk_Begin ,1)
 					  | ~1			  		  : StreetWithCrosswalkEnd }

Short_Street-->
 	ReportMultimodalMetrics(reportingOn)
 	BridgeMain
 	set( Right_Bike_Box ,"false")
 	set( Left_Bike_Box ,"false")
 	set( Stop_Begin ,"none")
 	set( Stop_End ,"none")
 	StreetWithEntries

ReportMultimodalMetrics(report_bool)-->
	case report_bool:
		report("Modal Preference (0 to 1).Bicycle", _BikeRank)
		report("Modal Preference (0 to 1).Pedestrian", _PedRank)
		report("Modal Preference (0 to 1).Transit", _TransitRank)
		report("Modal Preference (0 to 1).Auto", _AutoRank)
		report("Speed.Braking Distance (ft)",Braking_Dist)#Assumes Level elevation
		report("Speed.Braking Reaction Distance (ft)",Brake_Reaction_Dist)#Assumes Level elevation
		report("Speed.Stopping Sight Distance (ft)",Stopping_Sight_Dist)#Design Value is rounded to nearest 5 feet,Assumes Level elevation
		NIL
	else:
		NIL
		
 
# split away the crosswalks at the end (if any) using the special UVSET 2
StreetWithCrosswalkEnd -->	
	#print("DirLane "+str(DirLaneTotal))
	split(u,uvSpace,2){ _crosswalkEndWidth/10: Asphalt("Auto","asphalt")
					  | _crosswalkEndWidth    : Crosswalk( Crosswalk_End ,2)
 					  | ~1			  		  : CrossWalkGap}
 					  
CrossWalkGap--> 
#This solution while imperfect and vulnerable to distortion prevents UVspace/UnitSpace conflicts from cutting geometry. User can adjust relative gaps to compensate. 
	split(u,unitSpace,0) {( Begin_Crosswalk_To_Stop_Bar ):Asphalt("Auto","asphalt")
						 |~1:StreetWithEntries
						 |( End_Crosswalk_To_Stop_Bar ):Asphalt("Auto","asphalt")} 
# split into the two street sides (if not oneway)
StreetWithEntries -->
	split(v,unitSpace,0) {~1:Drainage
						|(_RightSplitSum+ _Distribute_Right_Lanes* _Actual_Lane_Width+_Rt_Transit_Lane_Width):scaleUV(0,DirectionalFlip,1)StopBox("RightSide")# Will flip with a change in driving direction
						| _centerWidth											  : scaleUV(0,DirectionalFlip,1)CenterSpaceReporting# Will flip with a change in driving direction
						|(_LeftSplitSum+nLanesLeft*_Actual_Lane_Width+_Lt_Transit_Lane_Width)	  :scaleUV(0,DirectionalFlip,1)StopBox("LeftSide")# Will flip with a change in driving direction
						|~1:Drainage}


#The StopBox rule creates both the stop line and Bikebox when they are selected, 
#and then moves the rest of the space left to the dedicated lane spaces. 
StopBox(RuleChoice)--> 
	case RuleChoice=="RightSide":
		case Right_Bike_Box_Bool && geometry.dv(0,unitSpace)>BikeBoxGeometryThreshold :#Must be enough room, turned on. 
			split(u,unitSpace,0) {~1:RightSide| Bike_Box_Length :BikeBoxCreation(0)}
		else:
			split(u,unitSpace,0) {~1:RightSide|_stopEnd*ThickPaintLineWidth:AsphaltPainted("white","Auto","stop_bar")}
		
	case RuleChoice=="LeftSide":
		case  Left_Bike_Box_Bool && geometry.dv(0,unitSpace)>BikeBoxGeometryThreshold: #Must be enough room, turned on. 
			split(u,unitSpace,0) { Bike_Box_Length :BikeBoxCreation(2)|~1:LeftSide}
		else:
			split(u,unitSpace,0) {_stopBegin*ThickPaintLineWidth:AsphaltPainted("white","Auto","stop_bar")|~1:LeftSide}	
	else:
		case RuleChoice=="RightSide":
		split(u,unitSpace,0) {~1:RightSide|_stopEnd*ThickPaintLineWidth:AsphaltPainted("white","Auto","stop_bar")}
		else:
		split(u,unitSpace,0) {_stopBegin*ThickPaintLineWidth:AsphaltPainted("white","Auto","stop_bar")|~1:LeftSide}
		

# Divides the two street sides into left subsection made up of splitspace (holds bike, parking, and buffer),repeater conventional lanes, and transit lanes (activiated by Location Switch).  
RightSide-->
	split(v,unitSpace,0){(_Transit_Lane_Width_Switch(0,"Sidewalk Side")):Transit_Lane_Reporting(0)
						|_RightSplitSum:RightSplitSpace 
						|(_Transit_Lane_Width_Switch(0,"Right Most Lane")):Transit_Lane_Reporting(0)
						|( _Distribute_Right_Lanes* _Actual_Lane_Width):Lanes(0,(case rightHandTraffic: Stop_End else: Stop_Begin))
						|(_Transit_Lane_Width_Switch(0,"Left Most Lane")):Transit_Lane_Reporting(0)}
# Divides the two street sides into left subsection made up of splitspace (holds bike, parking, and buffer),repeater conventional lanes, and transit lanes (activiated by Location Switch). 
LeftSide-->
	split(v,unitSpace,0){(_Transit_Lane_Width_Switch(2,"Left Most Lane")): scaleUV(0,-1,-1) Transit_Lane_Reporting(2)
						|(nLanesLeft*_Actual_Lane_Width ):  translateUV(0,0,-geometry.vMax) scaleUV(0,-1,-1)    # mirror the uv coords
					  			Lanes(2,(case rightHandTraffic: Stop_Begin else: Stop_End) )
					  	|(_Transit_Lane_Width_Switch(2,"Right Most Lane")):scaleUV(0,-1,-1) Transit_Lane_Reporting(2)
					  	|_LeftSplitSum:LeftSplitSpace
					  	|(_Transit_Lane_Width_Switch(2,"Sidewalk Side")):scaleUV(0,-1,-1) Transit_Lane_Reporting(2)}	  
# "Sidewalk Side","Right Most Lane","Left Most Lane"

	
##
##Note about Dir Variable-#Dir represents direction 0 for right, 2 for left. Any other number is to handle an exception.
## 
##
# split lanes into a single lane each and respective transit lane (location based transit lanes)
Lanes(dir,stopType) -->
	split(v,unitSpace,0){{~_Actual_Lane_Width : LaneReporting(dir,split.total,split.index,stopType,"MainLanes")}*}
	#print(geometry.dv(0,unitSpace))
	#print(split.total)
# prepare the uv coordinates and texture the shape
ApproachMarkings(dir,lanenumber,lanestotal,stopType) -->	# is used for textures for intersection approach (stop,turn arrows etc). 
	case !Not_Low_LOD:
		LowLODApproachMarkings(dir,lanenumber,lanestotal,_stopTex(stopType,lanenumber,lanestotal)) 
	else:
		HighLODApproachMarkings(dir,lanenumber,lanestotal,_stopSten(stopType,lanenumber,lanestotal))

LowLODApproachMarkings(dir,lanenumber,lanestotal,markings) -->	# is used for textures for intersection approach (stop,turn arrows etc). 
	tileUV(0,~14,~Lane_Width )				# the tileUV operation makes sure that one unit in u-space corresponds to approx 14 meters, the v-coord is not touched in the case of 0 as parameter
	normalizeUV(0,v,separatePerFace)
	scaleUV(0,1,(case (lanenumber==lanestotal-1):.95 else: 1))# Scale UV in V direction slightly to remove light line on lane closer to centerline. 
	texture(LanesFolder+"/lanes_4"+markings+"_14x14m.jpg")
	ColorAndReport("Auto","drive_lane")
	
HighLODApproachMarkings(dir,lanenumber,lanestotal,markings)-->
	split(v,unitSpace,0) {~1:Asphalt("Auto","drive_lane") ApproachSymbolStencilsSetup(dir,lanenumber,lanestotal,markings)|
								_LastLaneSwitch(lanenumber,lanestotal)*PaintLineWidth:AsphaltPainted("white","Auto","drive_lane")}
	
ApproachSymbolStencilsSetup(dir,lanenumber,lanestotal,markings)-->
	split(v,unitSpace,0) {'0.1:NIL
		  				 |~1:split(u,unitSpace,0){'0.65:NIL
		  					 |~1:ApproachSymbolStencils(dir,lanenumber,lanestotal,markings)
		  					 |'0.15:NIL}
						  |'0.1:NIL}
						  
ApproachSymbolStencils(dir,lanenumber,lanestotal,markings)-->
	case find(str(markings),"Nothing",0)!=-1:
		NIL
	else:
		normalizeUV(0, uv, collectiveAllFaces)
		rotateUV(0,90)
		insertAlongUV(0, StencilFolder+"/"+markings, 0)
		comp (f) {top:AsphaltPaintedStencil(Stencil_Color ,"Bikeways","bike_lane")}


MainLaneMarkings(dir,lanenumber,markings)--> #Ground Textured Rule	
	tileUV(0,~14,~ Lane_Width )				# the tileUV operation makes sure that one unit in u-space corresponds to approx 14 meters, the v-coord is not touched in the case of 0 as parameter
	scaleUV(0,_uScale,1/4)				    # flip direction if needed, handle short lanes with _uScale, and scaling the v coord for the texture (e.g. a street with 2 lanes has v coords from 0 to 2, this means it has to map onto 0 to 2/8 on our texture with its 8 lanes)	
	texture( LanesFolder+"/lanes_4"+markings+"_14x14m.jpg")
	ColorAndReport("Auto","drive_lane")
	
#This rule contains the reports for the lanes defined by the lanes rule, no bike/pking lanes etc. 
LaneReporting(dir,lanestotal,lanenumber,stopType,laneType)-->
	report("Lane Width.Actual Lane Width (ft)",geometry.dv(0,unitSpace)*Feet) #Used to provide lane widths in feet
	ConventionalLane(dir,lanestotal,lanenumber,stopType)
	#print("Lanestotal: "+str(lanestotal-1))
	#print(lanenumber)


#################################
#Lane choice Region				#
#################################	
	
######################
#Convential Lane Set Up
#	
ConventionalLane(dir,lanestotal,lanenumber,stopType)-->
	case (stopType=="none"||stopType=="line only") && (lanenumber==lanestotal-1):# Makes sure with no stop type last lane has no lane with contiguous stripes
		Asphalt("Auto","drive_lane")
		MixedTrafficOnLane (dir,lanenumber,lanestotal)
		Sharrow(dir,lanestotal,lanenumber)
	case !(stopType=="none"||stopType=="line only") && (lanenumber==lanestotal-1):# Makes sure with no stop type last lane has no lane with contiguous stripes
		split(u,unitSpace,0){ ~1: Asphalt("Auto","drive_lane")
 							| 14: ApproachMarkings(dir,lanenumber,lanestotal,stopType) }
 		MixedTrafficOnLane (dir,lanenumber,lanestotal)
 		Sharrow(dir,lanestotal,lanenumber)
	else:	# Makes basic lanes that that are not next to the last lane or a bus/hov lane (if they are on).
		split(u,unitSpace,0){ ~1: MainLaneMarkingLODChoice(dir,lanenumber,"_stripes_white")
 							| _hasStopSideSwitch(dir)* 14: ApproachMarkings(dir,lanenumber,lanestotal,stopType)}
 		MixedTrafficOnLane (dir,lanenumber,lanestotal)
 		Sharrow(dir,lanestotal,lanenumber)
 		
MainLaneMarkingLODChoice(dir,lanenumber,marking)-->
	case !Not_Low_LOD:
		MainLaneMarkings(dir,lanenumber,"_stripes_white")
	else:
		HighLODLaneMarking(dir,lanenumber,"Auto","drive_lane")
		
HighLODLaneMarking(dir,lanenumber,Mode,LabelID)-->
	split(v,unitSpace,0) {~1:Asphalt(Mode,LabelID)|PaintLineWidth:Repeated_Lane_Dash("white",Mode,LabelID)}

Repeated_Lane_Dash(Color,Mode,LabelID)-->
	split(u,unitSpace,0) {~4:Asphalt(Mode,LabelID)|{~4:AsphaltPainted(Color,Mode,LabelID)|~4:Asphalt(Mode,LabelID)}*}	

						
#######################################################
#######################################################
#Multimodal Lane Creation and Non-Car Lane Splits

Sharrow(dir,lanestotal,lanenumber)-->
	case lanenumber==0 && Bike_Lane_Type=="Sharrow":
		case dir==0 && Street_Right_Bike_Lane_Width<=0:
			alignScopeToAxes(y)
			#t(0,sharrowHeight,0) # Optional method of representing stamp
			split(u,unitSpace,0){~1:NIL
					|2:split(v,unitSpace,0)
						{~0.5:NIL|
						1.5:Sharrow_Stamp(dir,lanestotal,lanenumber)
						|~1.5:NIL}
				|~Bike_Symbol_Spacing:NIL}*	
		case dir==2 && Street_Left_Bike_Lane_Width<=0:
			alignScopeToAxes(y)
			#t(0,sharrowHeight,0) # Optional method of representing stamp
			split(u,unitSpace,0){~1:NIL
					|2:split(v,unitSpace,0)
						{~0.5:NIL|
						1.5:Sharrow_Stamp(dir,lanestotal,lanenumber)
						|~1.5:NIL}
				|~Bike_Symbol_Spacing:NIL}*
		else:
			NIL	
	else:
		NIL
		
Sharrow_Stamp(dir,lanestotal,lanenumber)-->
	extrude(sharrowHeight)
	comp(f) {top: Sharrow_Stamp_Top
			|side:AsphaltPainted(Bike_Lane_Color,"Bikeways","bike_lane")}
						
Sharrow_Stamp_Top-->
	AsphaltPainted(Bike_Lane_Color,"Bikeways","bike_lane")
	alignScopeToGeometry(yUp,largest,longest)
	BikeLaneSymbolStencil	
		
Transit_Lane_Reporting(dir)--> #Reports based on shape geometry and sends to allocator
	report("Lane Width.Transit Lane Width (ft)",geometry.dv(0,unitSpace)*Feet) #Used to provide lane widths in feet
	Transit_Lane_Allocator(dir)

Transit_Lane_Allocator(dir)--> #Allocates the texture rule based on what type of transit lane is selected. 
	case Transit_Lane=="Bus Lane":
		Bus_Lane_Texture_Rule(dir)
	case Transit_Lane=="Bus-Bike Lane":
		Bus_Bike_Lane_Texture_Rule(dir)
	case Transit_Lane=="HOV Lane":
		HOV_Lane_Texture_Rule(dir)
	case Transit_Lane =="Light Rail Lane":
		Light_Rail_Lane_Texture(dir)
	else: #Do not leave blank geometry. 
		Bus_Lane_Texture_Rule(dir)


Bus_Lane_Texture_Rule(dir)--> 
	alignScopeToAxes(y)
	split(v,unitSpace,0){PaintLineWidth*_PaintLineControl("Right", Transit_Paint_Line_Sides ):AsphaltPainted("white","Transit","bus_lane")
							#Level 1-First split indentation
							|~1:AsphaltPainted(Bus_Lane_Color,"Transit","bus_lane") split(u,unitSpace,0){2:NIL
								#Level 2- sub-split indentation
								| Transit_Lane_Width: Bus_Lane_Stencil_Setup(dir)
								|~ Transit_Symbol_Spacing :NIL
								|{ Transit_Lane_Width : Bus_Lane_Stencil_Setup(dir)
								|~ Transit_Symbol_Spacing :NIL}*
								| _tooShort(geometry.du(0,unitSpace),Transit_Symbol_Spacing)*_hasStopSideSwitch(dir)*Transit_Lane_Width: Bus_Lane_Stencil_Setup(dir)
								|2:NIL}
							|PaintLineWidth*_PaintLineControl("Left", Transit_Paint_Line_Sides ):AsphaltPainted("white","Transit","bus_lane")}
	BusOnLane(dir)

Bus_Bike_Lane_Texture_Rule(dir)--> 
	alignScopeToAxes(y)
	split(v,unitSpace,0){PaintLineWidth*_PaintLineControl("Right", Transit_Paint_Line_Sides ):AsphaltPainted("white","Transit","bus_lane")
							#Level 1-First split indentation
							|~1:AsphaltPainted(Bus_Lane_Color,"Transit","bus_lane") split(u,unitSpace,0){2:NIL
								#Level 2- sub-split 
								| Transit_Lane_Width*.75: BikeBoxSymbolAllocation(1,Transit_Lane_Width*.5, Transit_Lane_Width*.75,Bus_Lane_Color)
								| Transit_Lane_Width: Bus_Lane_Stencil_Setup(dir)
								|~ Transit_Symbol_Spacing :NIL
								|{ Transit_Lane_Width*.75: BikeBoxSymbolAllocation(1,Transit_Lane_Width*.5, Transit_Lane_Width*.75,Bus_Lane_Color)
								|Transit_Lane_Width: Bus_Lane_Stencil_Setup(dir)
								|~ Transit_Symbol_Spacing :NIL}*
								| _tooShort(geometry.du(0,unitSpace),Transit_Symbol_Spacing)*_hasStopSideSwitch(dir)*Transit_Lane_Width * .75: BikeBoxSymbolAllocation(1,Transit_Lane_Width*.5, Transit_Lane_Width*.75,Bus_Lane_Color)
								| _tooShort(geometry.du(0,unitSpace),Transit_Symbol_Spacing)*_hasStopSideSwitch(dir)*Transit_Lane_Width: Bus_Lane_Stencil_Setup(dir)
								|2:NIL}
							|PaintLineWidth*_PaintLineControl("Left", Transit_Paint_Line_Sides ):AsphaltPainted("white","Transit","bus_lane")}
	BusOnLane(dir)
	
Light_Rail_Lane_Texture(dir)-->	
	color( _ThematicRouter ("Transit"))
	split(v,unitSpace,0){~1:Sidewalk_Pavement("Light Rail Lane")NoGeometryModeReporter("Transit")|
						 Rail_Depth*3:Rail_Inset|
						 Track_Gauge:Sidewalk_Pavement("Light Rail Lane")NoGeometryModeReporter("Transit")|
						 Rail_Depth*3:Rail_Inset|
						 ~1:Sidewalk_Pavement("Light Rail Lane")NoGeometryModeReporter("Transit")}
	
						 

Rail_Inset-->
	split(v,unitSpace,0) {Rail_Depth:Metal_Texture|
						  Rail_Depth: extrude(-Rail_Depth) comp(f){side:Metal_Texture|top:Metal_Texture NoGeometryModeReporter("Transit")}|
						  Rail_Depth:Metal_Texture}

Metal_Texture--> #Ground Textured Rule
	normalizeUV(0,uvUniform,separatePerFace)
	setupProjection(0,scope.xz,5,5)
	texture(MiscFolder +"/Metal_Texture.jpg")
	projectUV(0)
	Delete_Texture

Bus_Lane_Stencil_Setup(dir)-->
	split(v,unitSpace,0) {'0.05: NIL|~1:Bus_Lane_Stencil(dir)|'0.05: NIL}
	
Bus_Lane_Stencil(dir)--> #Ground Textured Rule
	scaleUV(0,1,DirectionalFlip)# Will flip with a change in driving direction
 	rotateUV(0,90)
 	normalizeUV(0, uv, collectiveAllFaces)	
	insertAlongUV(0, StencilFolder+"/Bus_Only.obj",0)
	setupProjection(0, scope.xz, ~2,~2,2,2,2)
	reverseNormals()
	comp (f) {top= AsphaltPaintedStencil(Stencil_Color ,"Transit","bus_lane")}
	
HOV_Lane_Texture_Rule(dir)--> #Ground Textured Rule
	split(v,unitSpace,0){PaintLineWidth*2*_PaintLineControl("Right", Transit_Paint_Line_Sides ):AsphaltPainted("yellow","Shared Mobility","hov_lane")
							#Level 1-First split indentation
							|~1:Asphalt("Shared Mobility","hov_lane")
								split(u,unitSpace,0){2:NIL
								#Level 2- sub-split indentation
								| Transit_Lane_Width :HOVLaneStencilSetUp(dir)
								|~ Transit_Symbol_Spacing :NIL
								|{ Transit_Lane_Width:HOVLaneStencilSetUp(dir)
								|~ Transit_Symbol_Spacing :NIL}*
								| _tooShort(geometry.du(0,unitSpace),Transit_Symbol_Spacing)*_hasStopSideSwitch(dir)*Transit_Lane_Width  :HOVLaneStencilSetUp(dir)
								|2:NIL}
							|PaintLineWidth*2*_PaintLineControl("Left", Transit_Paint_Line_Sides ):AsphaltPainted("yellow","Shared Mobility","hov_lane")}
	MixedTrafficOnLane (dir,-999,-999)
	
HOVLaneStencilSetUp(dir)-->
	split(v,unitSpace,0) {'0.3:NIL|~1:HOVLaneStencil(dir)|'0.3:NIL}

HOVLaneStencil(dir)-->
	alignScopeToAxes(y)
	scaleUV(0,1,DirectionalFlip)# Will flip with a change in driving direction
 	rotateUV(0,90)
 	normalizeUV(0, uv, collectiveAllFaces)	
	insertAlongUV(0, StencilFolder+"/HOV_Symbol.obj",0)
	setupProjection(0, scope.xz, ~2,~2,2,2,2)
	cleanupGeometry(all, 0.0075)
	reverseNormals()
	comp (f) {top=AsphaltPaintedStencil(Stencil_Color ,"Shared Mobility","hov_lane")}

##############################################################
#Non-Carlane Split Space- This is the space where 
#parking, bike, and buffer lanes are constructed. 

RightSplitSpace-->
	scaleUV(0,1,case Parking_Protection_Bool :-1 else:1)
	split(v,unitSpace,0){Right_Parking_Width :ParkingLane("Right",Right_Parking_Type,Right_Parking_Length,Right_Parking_Width,Right_Curbside_Allocation_Length)
						|( Street_Right_Bike_Lane_Width + Right_Buffer_Width ):RightBikeLaneSpace("list")}

LeftSplitSpace-->
	scaleUV(0,1,case Parking_Protection_Bool :-1 else:1)
	split(v,unitSpace,0){( Street_Left_Bike_Lane_Width + Left_Buffer_Width ):LeftBikeLaneSpace("list")
							| Left_Parking_Width :ParkingLane("Left",Left_Parking_Type,Left_Parking_Length,Left_Parking_Width,Left_Curbside_Allocation_Length)}
						
####################
#####BikeLane Rules- Includes Lane and Buffer
#Bike Space-Total
LeftBikeLaneSpace(list)--> 
	scaleUV(0,1,case Buffer_Protection_Bool : -1 else:1)
	scaleUV(0,1,case Parking_Protection_Bool :-1 else:1)
	split(v,unitSpace,0) { Street_Left_Bike_Lane_Width :BikeLaneSection(-1,Street_Left_Bike_Lane_Width)
						  |Left_Buffer_Width :BikeBuffer(Left_Buffer_Width,2)}

RightBikeLaneSpace(list)-->
	scaleUV(0,1,case Buffer_Protection_Bool : -1 else:1)
	scaleUV(0,1,case Parking_Protection_Bool :-1 else:1)
	split(v,unitSpace,0) {Right_Buffer_Width :BikeBuffer(Right_Buffer_Width,0)
						 |Street_Right_Bike_Lane_Width : BikeLaneSection (1,Street_Right_Bike_Lane_Width)}
#BikeLane Start
BikeLaneSection (flip,Side_Width)-->
	case _Twoway_Bikelane_Bool:
		scaleUV(0,1,case Buffer_Protection_Bool : 1 else:-1)
		split(v,unitSpace,0) {'.5:BikeLane(-1*Bike_Reversal_Switch,Side_Width)
		|~1:BikeLane(1*Bike_Reversal_Switch,Side_Width)}						
	else:
		scaleUV(0,1,case Buffer_Protection_Bool : 1 else:-1)
		BikeLane(flip*Bike_Reversal_Switch,Side_Width)
		
BikeLane(sideflip,Width)-->#Was Left,now both, fairly modular
	alignScopeToAxes(y)
	Bikes((case sideflip==1:0 else: 2),(case _Twoway_Bikelane_Bool:Width/2 else: Width),bikeProb)
	color( _ThematicRouter ("Bikeways"))#If Display Thematics==Usage, goes to usage, if not, Thematic. 
	scaleUV(0,sideflip,sideflip)
	split(v,unitSpace,0){PaintLineWidth*_PaintLineControl("Left", Bike_Paint_Line_Sides):BikeLaneLines
							#Level 1-First split indentation
							|~1:split(u,unitSpace,0){2:AsphaltPainted(Bike_Lane_Color,"Bikeways","bike_lane")
								#Level 2- sub-split indentation
								| Width*L_to_W_Ratio_Bk:AsphaltPainted(Bike_Lane_Color,"Bikeways","bike_lane") BikeLaneStencils(Width)
								|~ Bike_Symbol_Spacing :AsphaltPainted(Bike_Lane_Color,"Bikeways","bike_lane")
								|{Width*L_to_W_Ratio_Bk:AsphaltPainted(Bike_Lane_Color,"Bikeways","bike_lane") BikeLaneStencils(Width)
								|~ Bike_Symbol_Spacing :AsphaltPainted(Bike_Lane_Color,"Bikeways","bike_lane")}*
								| _tooShort(geometry.du(0,unitSpace)-Bike_Conflict_Spacing,Bike_Symbol_Spacing)*_hasStopSideSwitch((case sideflip==1:0 else: 2))* Width*L_to_W_Ratio_Bk:AsphaltPainted(Bike_Lane_Color,"Bikeways","bike_lane") BikeLaneStencils(Width)
								| Bike_Conflict_Spacing :ConflictZone(Bike_Lane_Color)
								|~1:AsphaltPainted(Bike_Lane_Color,"Bikeways","bike_lane")} 
							|PaintLineWidth*_PaintLineControl("Right", Bike_Paint_Line_Sides):BikeLaneLines}

BikeLaneLines-->
	split(u,unitSpace,0){~1:AsphaltPainted("white","Bikeways","bike_lane")
						|Bike_Conflict_Spacing:ConflictZone("white")
						|1:AsphaltPainted("white","Bikeways","bike_lane")}

BikeLaneStencils(Stamp_Width)-->
	split(v,unitSpace,0) {~Stamp_Width/10:NIL|
						 {~Stamp_Width:split(u,unitSpace,0){~1:BikeLaneSymbolStencil|
											 ~1:NIL|
											 ~1:BikeLaneArrowSetUp}|
						 ~Stamp_Width/10:NIL}}
BikeLaneArrowSetUp--> 
	split(v,unitSpace,0) {~1:NIL|~3:BikeLaneArrowStencil|~1:NIL}

BikeLaneArrowStencil--> 
	scaleUV(0,1,DirectionalFlip)# Will flip with a change in driving direction
	normalizeUV(0, uv, collectiveAllFaces)	
	insertAlongUV(0, StencilFolder+"/Bike_Arrow.obj",0)
	cleanupGeometry(all, 0.001) 
	comp (f) {top:AsphaltPaintedStencil(Stencil_Color ,"Bikeways","bike_lane")}
	

BikeLaneSymbolStencil--> #Ground Textured Rule
	scaleUV(0,1,DirectionalFlip)# Will flip with a change in driving direction
	normalizeUV(0, uv, collectiveAllFaces)	
	insertAlongUV(0, StencilFolder+"/Bike_Symbol.obj", 0)
	cleanupGeometry(all, 0.001) 
	comp (f) {top:AsphaltPaintedStencil(Stencil_Color,"Bikeways","bike_lane")}
	
		
ConflictZone(passedcolor)-->
	split(u,unitSpace,0){~1: AsphaltPainted(passedcolor,"Conflict Zones","conflict_marking")|~1:Asphalt("Conflict Zones","conflict_marking")}*

#Buffer Rules (Some Shared Rules in Median). 

BikeBuffer(Buffer_Width,Dir)-->
	case Buffer_Type=="Painted Stripes":
		color( _ThematicRouter ("Bikeways","bike_buffer"))#If Display Thematics==Usage, goes to usage, if not, Thematic. 
		Striped_Buffer(Buffer_Width)
	case Buffer_Type=="Solid White":
		color( _ThematicRouter ("Bikeways","bike_buffer"))#If Display Thematics==Usage, goes to usage, if not, Thematic. 
		AsphaltPainted("white","Bikeways","bike_buffer")
	case Buffer_Type=="Asphalt":
		Asphalt("Auto","bike_buffer")
	case Buffer_Type=="Shoulder":
		Shoulder(Dir)
	case Buffer_Type=="Curb Buffer with Trees" || Buffer_Type=="Curb Buffer with Plantings":
		color( _ThematicRouter ("Bikeways","bike_buffer"))#If Display Thematics==Usage, goes to usage, if not, Thematic. 
		Raised_Curb("Buffer",1)		
	case Buffer_Type=="Curb Buffer":
		color( _ThematicRouter ("Bikeways","bike_buffer"))#If Display Thematics==Usage, goes to usage, if not, Thematic. 
		Raised_Curb("Buffer",1)
	case Buffer_Type=="Cycle Track With Planters":
		color( _ThematicRouter ("Bikeways","bike_buffer"))#If Display Thematics==Usage, goes to usage, if not, Thematic. 
		Striped_Buffer(Buffer_Width)
		ObjectSetup("Planter",Buffer_Object_Spacing,"/Planter_"+LOD_Object_Choice+"_LOD.obj",Buffer_Width)
	case Buffer_Type=="Cycle Track With Tubular Markers":
		color( _ThematicRouter ("Bikeways","bike_buffer"))#If Display Thematics==Usage, goes to usage, if not, Thematic. 
		Striped_Buffer(Buffer_Width)
		ObjectSetup("Tubular Marker",Buffer_Object_Spacing,"/Tubular_Marker.obj",Buffer_Width)
	case Buffer_Type=="Cycle Track With Bollards":
		color( _ThematicRouter ("Bikeways","bike_buffer"))#If Display Thematics==Usage, goes to usage, if not, Thematic. 
		Striped_Buffer(Buffer_Width)
		ObjectSetup("Bollard",Buffer_Object_Spacing,"/Bollard.obj",Buffer_Width)
	case find(str(Buffer_Type),"Spaced Curb Buffer",0)!=-1:
		color( _ThematicRouter ("Bikeways","bike_buffer"))
		split(u,unitSpace,0) {{~Buffer_Object_Spacing:Asphalt("Bikeways","bike_buffer")
								|~Buffer_Object_Spacing:Raised_Curb_Forced_Ends("Buffer",1)}*
								|~Buffer_Object_Spacing:Asphalt("Bikeways","bike_buffer")}
	else:
		color( _ThematicRouter ("Bikeways","bike_buffer"))#If Display Thematics==Usage, goes to usage, if not, Thematic. 
		Striped_Buffer(Buffer_Width)
		
ObjectSetup(Object_Type,distance_between_objs,File_Extension,Width)-->
	alignScopeToAxes(y)
	alignScopeToGeometry(yUp,largest,longest)
	split(u,unitSpace,0){~.5:NIL
			|{Width*.9:Cycle_Track_ObjIns(Object_Type,File_Extension,Width)
			|~distance_between_objs:NIL}*
			|~.2:NIL}

Cycle_Track_ObjIns(Object_Type,Buffer_File,Width)-->
	alignScopeToAxes(y)
	alignScopeToGeometry(yUp,largest,0)
	s(0,0,0)
	i(ObjectFolder+Buffer_File)
	label(Object_Type)
	set(material.name,str(Object_Type))
	report("Objects."+Object_Type+ " Count",1)
	center(xz)
	Delete_Texture

Buffer_Tree_Split-->
	split(u,unitSpace,0) {Buffer_StartGap:NIL
						 |{~Buffer_Object_Spacing/2:NIL
						 |1:Tree_Setup("Buffer", Sidewalk_Tree_1_Percentage , Sidewalk_Tree_1_Type,Sidewalk_Tree_2_Type, Sidewalk_Tree_1_Height, Sidewalk_Tree_2_Height)
						 |~Buffer_Object_Spacing/2:NIL}*
						 |Buffer_StartGap:NIL}

Buffer_Top-->
	case Buffer_Type=="Curb Buffer with Trees":
		Sidewalk_Planting
		Buffer_Tree_Split
	case Buffer_Type=="Spaced Curb Buffer with Trees":
		Sidewalk_Planting
		Tree_Setup("Buffer", Sidewalk_Tree_1_Percentage , Sidewalk_Tree_1_Type,Sidewalk_Tree_2_Type, Sidewalk_Tree_1_Height, Sidewalk_Tree_2_Height )
	case find(Buffer_Type,"Curb Buffer with Plantings",0)!=-1:
		Sidewalk_Planting
	else:
		Buffer_Texture

Buffer_Texture--> #Ground Textured Rule
	tileUV(0,Sidewalk_Tile_Size,Sidewalk_Tile_Size) texture(Sidewalk_Texture)
	scaleUV(0, Sidewalk_Texture_Scale, Sidewalk_Texture_Scale)
	rotateUV(0, Sidewalk_Texture_Rotation)
	Delete_Texture

Shoulder(Dir)-->
	case Dir==0:
			split(v,unitSpace,0){PaintLineWidth:AsphaltPainted("white","Auto","asphalt")
									|Rumble_Strip_Wid:Rumble_Strip
									|~1:Asphalt("Auto","asphalt")}
	else:
			split(v,unitSpace,0){~1:Asphalt("Auto","asphalt")
								|Rumble_Strip_Wid:Rumble_Strip
								|PaintLineWidth:AsphaltPainted("white","Auto","asphalt")}

Striped_Buffer(Buffer_Width)-->
	split(u,unitSpace,0) {~Buffer_Width*1.5:Asphalt("Bikeways","bike_buffer") Bike_Buffer_Stencil("Bikeways","bike_buffer")}*
	
Bike_Buffer_Stencil(Mode,LabelID)-->
	alignScopeToAxes(y)
	normalizeUV(0, uv, collectiveAllFaces)	
	insertAlongUV(0, StencilFolder+"/Bike_Buffer_Center.obj", 0)
	cleanupGeometry(all, 0.001) 
	comp (f) {top:AsphaltPaintedStencil(Stencil_Color,Mode,LabelID)}

#Bike Box Creation Rule- controls the splits for the bike box. Works best if Bike lane is adjacent to sidewalk.
BikeBoxCreation(dir)-->
	case dir==2:#left
	split(v, unitSpace,0) {PaintLineWidth:AsphaltPainted("white","Bikeways","bike_lane")|
						  ~1:split(u, unitSpace,0){
						  	  PaintLineWidth:AsphaltPainted("white","Bikeways","bike_lane")
						  	  |~1:BikeBoxSymbolAllocation(dir,Bike_Box_Symbol_Spacing,Lane_Width,Bike_Box_Color_Override)
						  	  |ThickPaintLineWidth:AsphaltPainted("white","Bikeways","stop_bar")}
						  |(Street_Left_Bike_Lane_Width -PaintLineWidth*_Bike_Paint_Adjuster)*Bike_Box_Buffer_Adapter:split(u,unitSpace,0){
						  		PaintLineWidth:AsphaltPainted("white","Bikeways","bike_lane")|~1:AsphaltPainted(Bike_Box_Color_Override,"Bikeways","bike_lane")}
						  |PaintLineWidth:AsphaltPainted("white","Bikeways","bike_lane")}
	else:
		split(v, unitSpace,0) {PaintLineWidth:AsphaltPainted("white","Bikeways","bike_lane")
							  |(Street_Right_Bike_Lane_Width -PaintLineWidth*_Bike_Paint_Adjuster)*Bike_Box_Buffer_Adapter:split(u,unitSpace,0){
							  		~1:AsphaltPainted(Bike_Box_Color_Override,"Bikeways","bike_lane")|PaintLineWidth:AsphaltPainted("white","Bikeways","bike_lane")}
						  	  |~1:split(u, unitSpace,0){
						  	 	 ThickPaintLineWidth:AsphaltPainted("white","Bikeways","stop_bar")
						  	 	 |~1:BikeBoxSymbolAllocation(dir,Bike_Box_Symbol_Spacing,Lane_Width,Bike_Box_Color_Override)
						  	 	 |PaintLineWidth:AsphaltPainted("white","Bikeways","bike_lane")}
						  	  |PaintLineWidth:AsphaltPainted("white","Bikeways","bike_lane")}					  				  		  

BikeBoxSymbolAllocation(dir,symbol_spacing,allocation_width,bike_box_color)-->
	case dir==2: #left
		scaleUV(0,-1,1)
		AsphaltPainted(bike_box_color,"Bikeways","bike_lane")
		split(v,unitSpace,0) {~ symbol_spacing/2: NIL
								| allocation_width *BikeBox_Fraction: BikeBoxSymbolSetup(allocation_width)
								|~ symbol_spacing /2: NIL }*
	else:
		scaleUV(0,1,1) 
		AsphaltPainted(bike_box_color,"Bikeways","bike_lane")
		split(v,unitSpace,0) {~ symbol_spacing/2: NIL
								| allocation_width *BikeBox_Fraction: BikeBoxSymbolSetup(allocation_width)
								|~ symbol_spacing /2: NIL }*
BikeBoxSymbolSetup(Width)-->
	split(u,unitSpace,0) {~0.2:NIL|~Width:BikeLaneSymbolStencil|~0.2:NIL}							
########################
#####Parking Lane Rules
ParkingLane(Side,ParkingType,ParkingLength,ParkingWidth,CurbsideLength)-->
	case find(ParkingType,"Parallel",0)!=-1:
		ParallelParkingLane(Side,ParkingType,ParkingLength,ParkingWidth,CurbsideLength)	
 	case find(ParkingType,"Angled",0)!=-1:
 		AngledParkingLane(Side,ParkingType,ParkingLength,ParkingWidth,CurbsideLength)
	else:
		InformalStorageLane(Side)
		
InformalStorageLane(Side)-->
		report("Curbside Management.Other Length (m)",geometry.du(0,unitSpace))
		Asphalt("Storage","parking_lane")
		
ParallelParkingLane(Side,ParkingType,ParkingLength,ParkingWidth,CurbsideLength)-->
	color( _ThematicRouter ("Storage","parking_lane"))#If Display Thematics==Usage, goes to usage, if not, Thematic. 
 	scaleUV(0,
 			case Lane_Distribution==1:
 				-1
 			case Lane_Distribution==0:
 				1
 			else:	
 				case Side=="Right":-1 else:1,1)
 	split(u,unitSpace,0) {~_Front_Parking_Spacing(ParkingType):Asphalt("Auto","parking_lane")
 							|~CurbsideLength*_Allocate_Farside_Curbside(Curbside_Management_Position)*_HasCurbsideManagement(ParkingType):CurbsideAllocatorSide("Far-side",Side,ParkingType,ParkingLength, ParkingWidth)
 							|{ParkingLength:ParkingSpace(Side,ParkingType,split.index,split.total,ParkingLength,ParkingWidth)}*
 							|~CurbsideLength*_Allocate_Midpoint_Curbside(Curbside_Management_Position)*_HasCurbsideManagement(ParkingType):CurbsideAllocatorSide("Mid-block",Side,ParkingType,ParkingLength, ParkingWidth)
 							|{ParkingLength:ParkingSpace(Side,ParkingType,split.index,split.total,ParkingLength,ParkingWidth)}*
 							|~CurbsideLength*_Allocate_Nearside_Curbside(Curbside_Management_Position)*_HasCurbsideManagement(ParkingType):CurbsideAllocatorSide("Near-side",Side,ParkingType,ParkingLength, ParkingWidth)
 							|~_Rear_Parking_Spacing(ParkingType):Asphalt("Auto","parking_lane")} 
 		
AngledParkingLane(Side,ParkingType,ParkingLength,ParkingWidth,CurbsideLength)-->
 		color( _ThematicRouter ("Storage","parking_lane"))#If Display Thematics==Usage, goes to usage, if not, Thematic. 
 		scaleUV(0,case Side=="Right":-1 else:1,1)
 		split(u,unitSpace,0){~(_Front_Parking_Spacing(ParkingType)):Asphalt("Auto","parking_lane")# Make sure to pass right parameters/type shoudl work here
 							|{ParkingLength:ParkingSpace(Side,ParkingType,split.index,split.total,ParkingLength,ParkingWidth)}*
 							|~(_Rear_Parking_Spacing(ParkingType)):Asphalt("Auto","parking_lane")}	

ParkingSpace(Side,ParkingType,SpaceNumber,TotalSpacesonSide,ParkingLength,ParkingWidth)-->
 	case rand(0,1)<=Parklet_Percentage && SpaceNumber>1:
 		Asphalt("Pedestrian","parking_lane")
 		report("Curbside Management.Sidewalk Cafe (m)",geometry.du(0,unitSpace))
 		Parklet_Insert(ParkingLength,case Side=="Right":0 else: 180)			
	 case find(ParkingType,"Parallel",0)!=-1:
 		ParallelParking(Side,ParkingType,SpaceNumber,TotalSpacesonSide,ParkingLength,ParkingWidth)
 	case ParkingType=="Angled Nose In":
 		AngledNoseIn(Side,ParkingType,SpaceNumber,TotalSpacesonSide,ParkingLength,ParkingWidth)
 	else:
 		AngledNoseOutParking(Side,ParkingType,SpaceNumber,TotalSpacesonSide,ParkingLength,ParkingWidth)

CurbsideAllocatorSide(Position,Side,ParkingType,ParkingLength,ParkingWidth)-->
	case Side =="Right":
		RightCurbsideAllocator(Position,Side,ParkingType,ParkingLength,ParkingWidth)
	else:
		LeftCurbsideAllocator(Position,Side,ParkingType,ParkingLength,ParkingWidth)

RightCurbsideAllocator(Position,Side,ParkingType,ParkingLength,ParkingWidth)-->
	label("curbside_managed_zone")
	Curbside_Allocator(Position,Side,ParkingType,ParkingLength, ParkingWidth)
LeftCurbsideAllocator(Position,Side,ParkingType,ParkingLength,ParkingWidth)-->
	label("curbside_managed_zone")
	Curbside_Allocator(Position,Side,ParkingType,ParkingLength, ParkingWidth)
	
Curbside_Allocator(Position,Side,ParkingType,ParkingLength, ParkingWidth)-->
	case find(ParkingType,"Freight",0)!=-1:
		label("freight_loading_zone")
		Freight_Loading_Allocation(Side,ParkingWidth,ParkingLength)
	case find(ParkingType,"Passenger",0)!=-1:
		label("passenger_loading_zone")
		Passenger_Loading_Allocation(Side,ParkingWidth,ParkingLength)		
	case find(ParkingType,"Bus Stop",0)!=-1:
		label("bus_loading_zone")
		scaleUV(0,1,case Parking_Protection_Bool :-1 else:1)
		Bus_Stop_Allocation(Side,"black",ParkingWidth)
	case find(ParkingType,"Carshare",0)!=-1:
		label("carshare_parking")
		scaleUV(0,1,case Parking_Protection_Bool :-1 else:1)
		Carshare_Parking_Split(Side,"green",ParkingWidth,ParkingLength)
	case find(ParkingType,"DoBi & Scooter",0)!=-1:
		label("dobi_parking")
		DoBi_Scooter_Parking(Side,ParkingWidth,ParkingLength)
	else:
		InformalStorageLane(Side)
		
Freight_Loading_Allocation(Side,ParkingWidth,ParkingLength)-->
	report("Curbside Management.Freight Loading Length (m)",geometry.du(0,unitSpace))		
	split(v,unitSpace,0){
			PaintLineWidth:AsphaltPainted("yellow","Shared Mobility","freight_loading")|
			~1:split(u,unitSpace,0) {PaintLineWidth:AsphaltPainted("yellow","Shared Mobility","freight_loading")|
				~1: Project_Zebra_Stripe("yellow","Shared Mobility","freight_loading")|
				PaintLineWidth:AsphaltPainted("yellow","Shared Mobility","freight_loading")}|
			PaintLineWidth:AsphaltPainted("yellow","Shared Mobility","freight_loading")}
			
Passenger_Loading_Allocation(Side,ParkingWidth,ParkingLength)-->
	report("Curbside Management.Passenger Loading Length (m)",geometry.du(0,unitSpace))	
	split(v,unitSpace,0){
	PaintLineWidth:AsphaltPainted("white","Shared Mobility","passenger_loading")|
	~1:split(u,unitSpace,0) {PaintLineWidth:AsphaltPainted("white","Shared Mobility","passenger_loading")|
		~1:ParallelParkingCar(_ParParkedFacing(Side),scope.sx, ParkingWidth) Project_Zebra_Stripe("white","Shared Mobility","passenger_loading")|
		PaintLineWidth:AsphaltPainted("white","Shared Mobility","passenger_loading")}|
	PaintLineWidth:AsphaltPainted("white","Shared Mobility","passenger_loading")}
		
DoBi_Scooter_Parking(Side,ParkingWidth,ParkingLength)-->
	split(u,unitSpace,0){.025:Asphalt("Shared Mobility","bike_parking")|{~.5: DoBi_Scooter_Parking_Stamp(Side,ParkingWidth,ParkingLength)|.025:Asphalt("Shared Mobility","bike_parking")}*}

DoBi_Scooter_Parking_Stamp(Side,ParkingWidth,ParkingLength)--> #Ground Textured Rule
	report("Curbside Management.DoBi & Scooter Parking Length (m)",geometry.du(0,unitSpace))
	alignScopeToGeometry(yUp, largest, 0)
	split(v,unitSpace,0){PaintLineWidth:AsphaltPainted("white","Shared Mobility", "bike_parking")
						|~1: split(u,unitSpace,0) {
								PaintLineWidth:AsphaltPainted("white","Shared Mobility","bike_parking")
								|~1:Asphalt("Shared Mobility","bike_parking")
								|PaintLineWidth:AsphaltPainted("white","Shared Mobility","bike_parking")}
						|PaintLineWidth:AsphaltPainted("white","Shared Mobility", "bike_parking")}					

Carshare_Parking_Split(Side,Color,ParkingWidth,ParkingLength)-->
	split(u,unitSpace,0) {~ParkingLength:Carshare_Parking_Allocation(Side,Color,ParkingWidth,ParkingLength)}*
	
Carshare_Parking_Allocation(Side,Color,ParkingWidth,ParkingLength)-->
	report("Curbside Management.Carshare Parking Length (m)",geometry.du(0,unitSpace))
	split(v,unitSpace,0){
			PaintLineWidth:AsphaltPainted("green","Shared Mobility","parking_lane")|
			~ParkingWidth:split(u,unitSpace,0) {PaintLineWidth:AsphaltPainted("green","Shared Mobility","parking_lane")|	
				~ParkingLength:Asphalt("Shared Mobility","parking_lane") Carshare_Parking_Stencil_Setup(Side)|		
				PaintLineWidth:AsphaltPainted("green","Shared Mobility","parking_lane")}*|
			PaintLineWidth:AsphaltPainted("green","Shared Mobility","parking_lane")}

Carshare_Parking_Stencil_Setup(Side)-->
	split(v,unitSpace,0){'0.05:NIL|~1:split(u,unitSpace,0) {'0.1:NIL|~1:Carshare_Parking_Stencil(Side)|'0.1:NIL}|'0.05:NIL}

Carshare_Parking_Stencil(Side)--> #Ground Textured Rule
	alignScopeToGeometry(yUp, largest, 0)
	scaleUV(0,1,DirectionalFlip)# Will flip with a change in driving direction
 	scaleUV(0,1,case (Side=="Right" || Lane_Distribution==1) && Lane_Distribution!=0:1 else: -1)
 	normalizeUV(0, uv, collectiveAllFaces)	
	insertAlongUV(0, StencilFolder+"/Carshare_Only.obj",0)
	comp (f) {top= AsphaltPaintedStencil(Stencil_Color ,"Transit","bus_pull_in")}
		
Bus_Stop_Allocation(Side,Color,StampWidth)-->
	report("Curbside Management.Bus Stop Length (m)",geometry.du(0,unitSpace))
	split(v,unitSpace,0){
			PaintLineWidth:AsphaltPainted("white","Transit","bus_pull_in")|
			~1:split(u,unitSpace,0) {PaintLineWidth:AsphaltPainted("white","Transit","bus_pull_in")|
				~0.25:Asphalt("Transit","bus_pull_in")|
				StampWidth/4:Asphalt("Transit","bus_pull_in") Bus_Stop_Stencil_Setup(Side)|
				~9:Asphalt("Transit","bus_pull_in")|
				StampWidth/4:Asphalt("Transit","bus_pull_in") Bus_Stop_Stencil_Setup(Side)|
				~0.25:Asphalt("Transit","bus_pull_in")|
				PaintLineWidth:AsphaltPainted("white","Transit","bus_pull_in")}|
			PaintLineWidth:AsphaltPainted("white","Transit","bus_pull_in")}

Bus_Stop_Stencil_Setup(Side)-->
	split(v,unitSpace,0) {'0.2: NIL|~1:Bus_Stop_Stencil(Side)|'0.2: NIL}
	
Bus_Stop_Stencil(Side)--> #Ground Textured Rule
	alignScopeToGeometry(yUp, largest, 0)
	scaleUV(0,1,DirectionalFlip)# Will flip with a change in driving direction
 	scaleUV(0,1,case (Side=="Right" || Lane_Distribution==1) && Lane_Distribution!=0:1 else: -1)
 	rotateUV(0,90)
 	normalizeUV(0, uv, collectiveAllFaces)	
	insertAlongUV(0, StencilFolder+"/Bus_Stop.obj",0)
	comp (f) {top= AsphaltPaintedStencil(Stencil_Color ,"Transit","bus_pull_in")}
	
	
Project_Zebra_Stripe(Color,Mode_Class,LabelID)--> #Ground Textured Rule
	case !Not_Low_LOD:
		setupProjection(0,scope.xz,'1,'1)
		texture(LanesFolder +"/crosswalk_zebra_"+Color+".jpg")
		projectUV(0)
		ColorAndReport(Mode_Class,LabelID)
	else:
		cleanupGeometry(all, 0.001)
		split(u,unitSpace,0) {ThickPaintLineWidth:Asphalt(Mode_Class,LabelID)|
		                     {ThickPaintLineWidth:AsphaltPainted(Color,Mode_Class,LabelID)|
							ThickPaintLineWidth:Asphalt(Mode_Class,LabelID)}*}

Parklet_Insert(ParkingLength,Rotation)-->
	alignScopeToGeometry(yUp, largest, 1)
	rotateScope(0,Rotation,0)
 	s(scope.sx,0,scope.sz)
 	t(Parklet_Shift,0,0)
 	report("Objects.Parklet Count",1)
 	i(Parklet_Object)
 	set(material.name,"Parklet")
 	label("Parklet")
 	Delete_Texture
 	
AngledNoseIn(Side,ParkingType,SpaceNumber,TotalSpacesonSide,ParkingLength,ParkingWidth)-->
	AngledParkingCar((case Side=="Right":0 else:2),ParkingType,ParkingLength, ParkingWidth,SpaceNumber)
	Asphalt("Storage","parking_lane")
	scaleUV(0,-1,
 		(case Side=="Right":
 						(case Parking_Protection_Bool :1 else:-1)
 					 else:
 						(case Parking_Protection_Bool :-1 else:1)))
 	split(v,unitSpace,0){'0.24:NIL|~1:AngledParkingStencil(Side,ParkingLength,ParkingWidth)}
 	ParkingReport(Side,case SpaceNumber==1: false else:true,true)#Don't include last spot

AngledNoseOutParking(Side,ParkingType,SpaceNumber,TotalSpacesonSide,ParkingLength,ParkingWidth)-->
	Asphalt("Storage","parking_lane")
	AngledParkingCar((case Side=="Right":0 else:2),ParkingType,ParkingLength, ParkingWidth,SpaceNumber)
	scaleUV(0,1,(case Side=="Right":
 							(case Parking_Protection_Bool :1 else:-1)
 						 else:
 							(case Parking_Protection_Bool :-1 else:1)))
 	split(v,unitSpace,0){'0.24:NIL|~1:AngledParkingStencil(Side,ParkingLength,ParkingWidth)}
	ParkingReport(Side,case SpaceNumber==1: false else:true,true) #Don't include last spot
	


AngledParkingStencil(Side,ParkingLength,ParkingWidth)-->
	alignScopeToGeometry(yUp,largest,0)
	normalizeUV(0, uv, collectiveAllFaces)
	reverseNormals()	
	setupProjection(0, scope.xz, 2,2,2,2,2)
	insertAlongUV(0,StencilFolder+"/Angled_Parking_Line.obj",0)
	t(0,0,-.2)
	comp (f) {top=AsphaltPaintedStencil("white","Storage","parking_lane")}
	
ParallelParking(Side,ParkingType,SpaceNumber,TotalSpacesonSide,ParkingLength,ParkingWidth)-->
	case SpaceNumber==TotalSpacesonSide-2:#1 from index total, 1 from additional split- Start
 			ParallelParkingCar(_ParParkedFacing(Side),ParkingLength, ParkingWidth)# Fix Parking Angle on oneway Streets
			ParallelParkingTexture(Side,ParkingLength,ParkingWidth,true)
			ParkingCap(Side,_Parking_Cap_Angle(Side,"Begin"),"/Parking_Cap_End.obj")			
 			
 		case SpaceNumber==1:# End
 			ParallelParkingCar(_ParParkedFacing(Side),ParkingLength, ParkingWidth)
 			ParallelParkingTexture(Side,ParkingLength,ParkingWidth,true)
			ParkingCap(Side,_Parking_Cap_Angle(Side,"Middle"),"/Parking_Cap_Mid.obj")
			ParkingEndCap(Side,_Parking_Cap_Angle(Side,"End"),"/Parking_Cap_End.obj")
 			
 		else: # Middle
 			ParallelParkingCar(_ParParkedFacing(Side),ParkingLength, ParkingWidth)# Fix Parking Angle on oneway Streets-TODO
 			ParallelParkingTexture(Side,ParkingLength,ParkingWidth,true)
 			ParkingCap(Side,_Parking_Cap_Angle(Side,"Middle"),"/Parking_Cap_Mid.obj")			
ParkingCap (Side,Rotation,Obj_Path)-->
	scaleUV(0,-1,
 		(case Side=="Right":
 						(case Parking_Protection_Bool :1 else:-1)
 					 else:
 						(case Parking_Protection_Bool :-1 else:1)))
	split(v,unitSpace,0){0.6:split(u,unitSpace,0){0.6: ParkingInsertCap(Rotation,Obj_Path) 
						|~1:NIL|0.6:NIL}|~1:NIL}

ParkingEndCap(Side,Rotation,Obj_Path)-->
	scaleUV(0,-1,
 		(case Side=="Right":
 						(case Parking_Protection_Bool :1 else:-1)
 					 else:
 						(case Parking_Protection_Bool :-1 else:1)))
	split(v,unitSpace,0){0.6:split(u,unitSpace,0){0.6: NIL
						|~1:NIL|0.6:ParkingInsertCap(Rotation,Obj_Path) }|~1:NIL}

ParkingInsertCap (Rotation,Obj_Path)--> #Ground Textured Rule
	alignScopeToGeometry(yUp,largest,0)
	rotateScope(0,Rotation,0)
	i(StencilFolder+Obj_Path)
	AsphaltPaintedStencil(Stencil_Color,"Storage","parking_lane")

ParallelParkingTexture(Side,ParkingLength,ParkingWidth,ReportBool)-->
 	scaleUV(0,1,(case Side=="Right":
 		(case Parking_Protection_Bool :1 else:-1)
 		else:
 		(case Parking_Protection_Bool :-1 else:1)))
 	Asphalt("Storage","parking_lane")
 	ParkingReport(Side,ReportBool,true)	
	
ParallelParkingCar(dir,ParkingLength, ParkingWidth) -->
	case p(Parked_Car_Percentage):
		ParallelParkingCarStep2(dir,ParkingLength, ParkingWidth)	  			
	else: NIL

ParallelParkingCarStep2(dir,ParkingLength, ParkingWidth) -->
	alignScopeToGeometry(yUp, 0, (case dir==2:1 else:3))#If distortion is too high, the edge numbers might change making this look weird. Hard to evaluate options. 
	rotateScope(0,DirectionalRotation ,0) 
	s(0,0,0)
	i(vehicleAsset("car"))
	label("parked car")
	set(material.name,"parked_car")
	t(0,0,(ParkingLength/2))#+1) 
	center(x)
	color( _ThematicRouter ("Storage","car"))
	Delete_Texture
	
AngledParkingCar(dir,ParkingType,ParkingLength, ParkingWidth,SpaceNumber)-->
	case p(Parked_Car_Percentage)&& SpaceNumber!=1: #Don't include last spot
	  	case (dir == 2):
			AngledParkingCarStep2(-1,case ParkingType=="Angled Nose In":1 else:-1,Left_Parked_Car_Angle,ParkingLength, ParkingWidth)	  		
		else:
			AngledParkingCarStep2(1,case ParkingType=="Angled Nose In":1 else:-1,Right_Parked_Car_Angle,ParkingLength, ParkingWidth)
	else: NIL
	
AngledParkingCarStep2(DirsenseFlip,NoseSenseFlip,Rotation_Angle,ParkingLength, ParkingWidth)-->
	alignScopeToGeometry(yUp, 0, (case DirsenseFlip==-1:3 else:1))#If distortion is too high, the edge numbers might change making this look weird. Hard to evaluate options. 
	s(0,0,0)
	t((ParkingWidth/2.3),0,(ParkingLength)) # Suggest changing base concept later.
	rotateScope(0,NoseSenseFlip*-Rotation_Angle,0)
	i(vehicleAsset("car"))
	label("parked car")
	Delete_Texture
	
ParkingReport(Side,Rear_Edge_Case,Delete_Geo)-->#This edge case parameter only makes sure the correct number of parking spaces is reported. 
	case Delete_Geo:
		case Rear_Edge_Case:
			report("Parking."+Side+" Parking Space Area (m^2)",geometry.area)
			report("Parking.Total Parking Space Area (m^2)",geometry.area)
			report("Curbside Management.On-Street Parking Length (m)",geometry.du(0,unitSpace))	
			NIL
		else:
			NIL
	else:
		case Rear_Edge_Case:
			report("Parking."+Side+" Parking Space Area (m^2)",geometry.area)
			report("Parking.Total Parking Space Area (m^2)",geometry.area)
			report("Curbside Management.On-Street Parking Length (m)",geometry.du(0,unitSpace))
				
		else:
			X.
###################################################
# Centerline and Center Section Code
#
CenterSpaceReporting-->
	report("Center.Center Section Area",geometry.area)
	color( _ThematicRouter ("Auto","median"))#If Display Thematics==Usage, goes to usage, if not, Thematic. 
	CenterSpace
	
CenterSpace -->
	case Center_Type =="Median":
		Raised_Curb("Median",1)# IF a median, and this will be use dto make a different rule
	case Center_Type =="Median With Turn Lane":
		MedianWTurnLane
	case Center_Type =="Boulevard":
		Boulevard
	case Center_Type =="Barrier":
		split(u,unitSpace,0) {{2:Barrier }*|1:Asphalt("Auto","asphalt")}
		Asphalt("Auto","asphalt")
	case Center_Type =="Barrier & Shoulder":
		split(u,unitSpace,0) {{2:split(v,unitSpace,0){~1:NIL |.98:Barrier |~1:NIL}}*}
		split(v,unitSpace,0) {Rumble_Strip_Wid:Rumble_Strip
							 |~1:Asphalt("Auto","asphalt")
							 |Rumble_Strip_Wid:Rumble_Strip}
	case Center_Type=="Center Turn Lane":
		Center_Turn_Lane
	case Center_Type=="None":
		Asphalt("Auto","asphalt")	
	case Center_Type == "White Stripe Centerline":
		Striped_Centerline
	else:
		CenterLineMarkings(Centerline_Color,"Auto","centerline")

Striped_Centerline-->
	split(u,unitSpace,0){ _stopBegin*21: CenterLineMarkings("white","Auto","centerline")
						| ~1		   : split(u,unitSpace,0){~5: CenterLineMarkings("white","Auto","centerline")|~5:Asphalt("Auto","asphalt")}*
						| _stopEnd*21  : CenterLineMarkings("white","Auto","centerline") }



MedianWTurnLane-->
	split(u,unitSpace,0){(_Bike_Box_Gap("Begin")): Bike_Box_Left_Turn_Gap("Begin")
						|_neighborBegin*_stopBegin*ThickPaintLineWidth:AsphaltPainted("white","Auto","stop_bar")
						|(_tooShort(geometry.du(0,unitSpace),Total_Median_Turn_Depth ))*_neighborBegin*_stopBegin*(Total_Median_Turn_Depth ):MedianTurnPocket("Median",0)
						|~1:Raised_Offset_Curb("Median",1,"Auto",Center_Width/4)
						|(_tooShort(geometry.du(0,unitSpace),Total_Median_Turn_Depth ))*_neighborEnd*_stopEnd*(Total_Median_Turn_Depth ):MedianTurnPocket("Median",2)
						|_neighborEnd*_stopEnd*ThickPaintLineWidth:AsphaltPainted("white","Auto","stop_bar")
						|(_Bike_Box_Gap("End")): Bike_Box_Left_Turn_Gap("End")}

MedianTurnPocket(Location,dir)-->
	scaleUV(0,case dir==0:-1 else: 1,case dir==0:1 else: -1)
	split(u,unitSpace,0){Median_Turn_Transition_Depth:MedianTransitionSpace(Location,dir)
	|~1:RaisedTurnLanePocket(dir)}

		
MedianTransitionSpace(Location,dir)-->
	split(v,unitSpace,0){Turn_Pocket_Curb_Width:Raised_Offset_Curb("Turn Lane Curb",1,"Auto",Turn_Pocket_Curb_Width)
						|~1: RaisedAngledSplitTransition(Location,dir)}			

RaisedAngledSplitTransition(Location,dir)-->
	RaisedTransitionInsert(Location,dir)
	Asphalt("Auto","asphalt")

RaisedTransitionInsert(Location,dir)-->
	normalizeUV(0, uv, collectiveAllFaces)	
	setupProjection(0, scope.xz, 2,2,2,2,2)
	insertAlongUV(0,Default_Median_Transition,0)
	comp (f) {top:Raised_Curb_End_Extrusion("Auto",dir)}
	
RaisedTurnLanePocket(dir)-->
	split(v,unitSpace,0){
		Turn_Pocket_Curb_Width:split(u,unitSpace,0) {~1:Raised_Offset_Curb("Turn Lane Curb",1,"Auto",Turn_Pocket_Curb_Width)
									|Turn_Pocket_Curb_Width:Asphalt("Auto","asphalt") Raised_Curb_End("Median With Turn Lane",dir)}
						|{~Lane_Width: ApproachMarkings(dir,1,1,"right;")}*}#Right because UV is scaled at beginning
Center_Turn_Lane-->
	case !Not_Low_LOD:
		Center_Turn_Lane_Low_LOD
	else:
		Center_Turn_Lane_High_LOD

Center_Turn_Lane_Low_LOD-->
	split(u,unitSpace,0){(_Bike_Box_Gap("Begin")): Bike_Box_Left_Turn_Gap("Begin")
						|_neighborBegin*_stopBegin*ThickPaintLineWidth:AsphaltPainted("white","Auto","stop_bar")
						|(_tooShort(geometry.du(0,unitSpace),18+ThickPaintLineWidth))*_neighborBegin*_stopBegin*18:CenterTurnLaneStamp("Transition_",180)
						| ~Lane_Width :CenterTurnLaneStamp("",90)
						|{~ Lane_Width :CenterTurnLaneStamp("",90)
						| Lane_Width :CenterTurnLaneStamp("Turn_",90)
						| ~Lane_Width :CenterTurnLaneStamp("",90)}*
						| ~Lane_Width :CenterTurnLaneStamp("",90)
						|(_tooShort(geometry.du(0,unitSpace),18+ThickPaintLineWidth))*_neighborEnd*_stopEnd*18:CenterTurnLaneStamp("Transition_",0)
						|_neighborEnd*_stopEnd*ThickPaintLineWidth:AsphaltPainted("white","Auto","stop_bar")
						|(_Bike_Box_Gap("End")): Bike_Box_Left_Turn_Gap("End")}

Center_Turn_Lane_High_LOD-->
	split(u,unitSpace,0){(_Bike_Box_Gap("Begin")): Bike_Box_Left_Turn_Gap("Begin")
						|_neighborBegin*_stopBegin*ThickPaintLineWidth:AsphaltPainted("white","Auto","stop_bar")
						|(_tooShort(geometry.du(0,unitSpace),Total_TWLTL_Turn_Depth))*_neighborBegin*_stopBegin*(Total_TWLTL_Turn_Depth ):CenterTurnLaneTurnPocket("Center Turn Lane",0)
						| ~1:CenterTurnLanePattern
						|(_tooShort(geometry.du(0,unitSpace),Total_TWLTL_Turn_Depth))*_neighborBegin*_stopBegin*(Total_TWLTL_Turn_Depth ):CenterTurnLaneTurnPocket("Center Turn Lane",2)
						|_neighborEnd*_stopEnd*ThickPaintLineWidth:AsphaltPainted("white","Auto","stop_bar")
						|(_Bike_Box_Gap("End")): Bike_Box_Left_Turn_Gap("End")}

CenterTurnLanePattern-->
	split(v,unitSpace,0){ModeratePaintLineWidth:AsphaltPainted("yellow","Auto","center_turn_lane")
						|ModeratePaintLineWidth:Asphalt("Auto","center_turn_lane")
						|~1:split(u,unitSpace,0){~Lane_Width:CenterTurnLaneStencilSections("black")
											|{~Lane_Width:CenterTurnLaneStencilSections("yellow")
											|~Lane_Width:CenterTurnLaneStencilSections("black")}*}
						|ModeratePaintLineWidth:Asphalt("Auto","center_turn_lane")
						|ModeratePaintLineWidth:AsphaltPainted("yellow","Auto","center_turn_lane")}

CenterTurnLaneStencilSections(EdgeColor)-->						
	split(v,unitSpace,0) {ModeratePaintLineWidth:AsphaltPainted(EdgeColor,"Auto","center_turn_lane")
						 |~1:Asphalt("Auto","center_turn_lane") CenterTurnLaneArrowSetup(EdgeColor,"Auto","center_turn_lane")
						 |ModeratePaintLineWidth:AsphaltPainted(EdgeColor,"Auto","center_turn_lane")}

CenterTurnLaneArrowSetup(EdgeColor,Mode,LabelID)-->
	case EdgeColor == "black":
		NIL
	else:
		split(v,unitSpace,0) {'0.25:NIL|
							 ~1:split(u,unitSpace,0) {'0.4:ApproachSymbolStencils(0,0,1,"Left_Arrow.obj")
								 |'0.2:NIL
								 |'0.4:scaleUV(0,-1,1) ApproachSymbolStencils(0,0,1,"Right_Arrow.obj")}	
						     |'0.25:NIL}
						     
CenterTurnLaneTurnPocket(Location,dir)-->
	scaleUV(0,case dir==0:-1 else: 1,case dir==0:1 else: -1)
	PaintedTransitionInsert(Location,dir)
	split(u,unitSpace,0){Median_Turn_Transition_Depth:Asphalt("Auto","asphalt")
	|~1: split(v,unitSpace,0) {'0.05:Asphalt("Auto","asphalt")|~1:ApproachMarkings(dir,1,1,"right;")}}


PaintedTransitionInsert(Location,dir)-->
	alignScopeToGeometry(yUp,largest,0)
	normalizeUV(0, uv, collectiveAllFaces)	
	setupProjection(0, scope.xz, 2,2,2,2,2)
	insertAlongUV(0,Default_TWLTL_Transition,0)
	comp (f) {top=AsphaltPaintedStencil("yellow","Auto","center_turn_lane")}
	
PaintedTurnLanePocket(dir)-->
	split(v,unitSpace,0){ModeratePaintLineWidth*3:CenterLineMarkings("yellow","Auto","center_turn_lane")
		|{~Lane_Width: ApproachMarkings(dir,1,1,"right;")}*}#Right because UV is scaled at beginning	
						     
					 				

Boulevard-->
	case Boulevard_Configuration=="Open Space": #If open space send to different split set up. 
	split(v,unitSpace,0){~(case WalkWay_Width==0:1 else:WalkWay_Width):Raised_Curb("Boulevard",0)
						|Boulevard_Inside_Width:Raised_Curb("Open Space",0)
						|~(case WalkWay_Width==0:1 else:WalkWay_Width):scaleUV(0,-1,-1) Raised_Curb("Boulevard",2)}	
	else: # If any type of lane set to Typical split set up. 
	split(v,unitSpace,0){~(case WalkWay_Width==0:1 else:WalkWay_Width):Raised_Curb("Boulevard",0)
						|Boulevard_Inside_Width/2-(Boulevard_Center_Width/2):Boulevard_StopBars(0)
						|Boulevard_Center_Width:Boulevard_Center
						|Boulevard_Inside_Width/2-(Boulevard_Center_Width/2): Boulevard_StopBars(2)
						|~(case WalkWay_Width==0:1 else:WalkWay_Width):Raised_Curb("Boulevard",2)}

Boulevard_StopBars(dir)-->
	case Boulevard_Configuration=="Bus Lanes":
		case dir==0:
			split(u,unitSpace,0) {~1:Bus_Lane_Texture_Rule(dir)|_stopEnd*ThickPaintLineWidth:AsphaltPainted("white","Auto","stop_bar")}
		else:
			split(u,unitSpace,0) {_stopBegin*ThickPaintLineWidth:AsphaltPainted("white","Auto","stop_bar")|~1:scaleUV(0,-1,-1)Bus_Lane_Texture_Rule(dir)}
	case Boulevard_Configuration=="Normal Lanes":
		case dir==0:
			split(u,unitSpace,0) {~1:Center_Normal_Lanes(dir)|_stopEnd*ThickPaintLineWidth:AsphaltPainted("white","Auto","stop_bar")}
		else:
			split(u,unitSpace,0) {_stopBegin*ThickPaintLineWidth:AsphaltPainted("white","Auto","stop_bar")|~1:scaleUV(0,-1,-1)Center_Normal_Lanes(dir)}
	else:
		case dir==0:
			split(u,unitSpace,0) {~1:BikeLane(1,geometry.dv(0,unitSpace))|_stopEnd*ThickPaintLineWidth:AsphaltPainted("white","Auto","stop_bar")}
		else:
			split(u,unitSpace,0) {_stopBegin*ThickPaintLineWidth:AsphaltPainted("white","Auto","stop_bar")|~1:BikeLane(-1,geometry.dv(0,unitSpace))}
Boulevard_Center-->
	case Boulevard_Center_Type=="Center Line":
		CenterLineMarkings(Centerline_Color,"Auto","centerline")
	case Boulevard_Center_Type=="Median":
		Raised_Curb("Boulevard Center",1) #HAS no bus stop
	case Boulevard_Center_Type=="Curb Buffer":
		Raised_Curb("Boulevard Center",1) #HAS no bus stop
	case Boulevard_Center_Type=="Tubular Markers":
		ObjectSetup("Tubular Marker",Center_Tube_Marker_Dist,"/Tubular_Marker.obj",1)
		Asphalt("Auto","asphalt")
	case Boulevard_Center_Type=="Chain Link Fence":
		split(u,unitSpace,0) {.3:NIL|~1:Fence("Boulevard Center")|.3:NIL}#The split only makes it so the fence poles are not put in the curb.
		Raised_Curb("Boulevard Center",1)
	case Boulevard_Center_Type=="Gate Fence":
		split(u,unitSpace,0) {.3:NIL|~1:Fence("Boulevard Center")|.3:NIL}#The split only makes it so the fence poles are not put in the curb.
		Raised_Curb("Boulevard Center",1)
	else:
		CenterLineMarkings(Centerline_Color,"Auto","centerline")

Center_Normal_Lanes(dir)-->
	 split(v,unitSpace,0) {~1:Drainage
	 					  |{ Lane_Width :MainLaneMarkings(0,split.index,"_stripes_white") MixedTrafficOnLane (dir,-999,-999)}*
	 					  | Lane_Width :Asphalt("Auto","asphalt") MixedTrafficOnLane (dir,-999,-999)}

CenterLineMarkings(line_color,Mode,LabelID) --> 
	split(v,unitSpace,0) {~PaintLineWidth:AsphaltPainted(line_color,Mode,LabelID)|
					 ~PaintLineWidth:Asphalt(Mode,LabelID)|
					 ~PaintLineWidth:AsphaltPainted(line_color,Mode,LabelID)}

CenterTurnLaneStamp(texture_choice,degree)--> #Ground Textured Rule
	normalizeUV(0,v,collectiveAllFaces)
	rotateUV(0,degree)
	tileUV(0, '1 ,'1)
	texture(LanesFolder+"/Center_"+texture_choice+"Lane"+".jpg")
	color( _ThematicRouter ("Auto","center_turn_lane"))#If Display Thematics==Usage, goes to usage, if not, Thematic. 
	ModeReporter ("Auto")
	Delete_Texture
	
Bike_Box_Left_Turn_Gap(street_side)--> #If Bike boxes are on for the correct side 
	case street_side=="Begin": split (u,unitSpace,0) {PaintLineWidth:AsphaltPainted("white","Conflict Zones","bike_lane")
									|~1:split(v,unitSpace,0)
									{PaintLineWidth:AsphaltPainted("white","Conflict Zones","bike_lane")| ~1:Asphalt("Conflict Zones","bike_lane")}}
	case street_side=="End": split (u,unitSpace,0) {~1:split(v,unitSpace,0){ ~1:Asphalt("Conflict Zones","bike_lane")|PaintLineWidth:AsphaltPainted("white","Conflict Zones","bike_lane")}
									|PaintLineWidth:AsphaltPainted("white","Conflict Zones","bike_lane")}
	else: Asphalt("Conflict Zones","asphalt") 
	
Barrier-->
	alignScopeToGeometry(yUp, largest, 0)
	rotateUV(0,90)
	normalizeUV(0,u,collectiveAllFaces)
	insertAlongUV(0,ObjectFolder+"/Jersey_Barrier.obj",1.2)
	Delete_Texture
	
#Raised Curb and Street_Pavement-
#This code is a fairly modular is called by several different rules. #Dir is 0 for right, 2, left, 1 middle or not assigned.
Raised_Curb(Location,Dir)-->
	Cut_And_Fill_Reporting(Location)
	Street_Lamp_Center(Location,Dir)
	split(u,unitSpace,0){_neighborBegin*_stopBegin* geometry.dv(0,unitSpace)/2:rotateUV(0,180)Raised_Curb_End(Location,Dir) Asphalt("Auto","asphalt")#End Curb
						|Curb_Depth:Curbs_Mass(true)
						|~1:split(v,unitSpace,0){ Curb_Depth:Curbs_Mass(false)ModeReporter((case Location=="Buffer":"Bikeways"else:"Pedestrian"))
							|~1:Street_Pavement(0,Location,Dir) ModeReporter((case Location=="Buffer":"Bikeways"else:"Pedestrian"))
							| Curb_Depth:Curbs_Mass(false)ModeReporter((case Location=="Buffer":"Bikeways"else:"Pedestrian"))}
						|Curb_Depth:Curbs_Mass(true)
						|_neighborEnd*_stopEnd* geometry.dv(0,unitSpace)/2:Raised_Curb_End(Location,Dir) Asphalt("Auto","asphalt")}#End Curb

Raised_Curb_End(Location,Dir)-->
	normalizeUV(0, uv, collectiveAllFaces)	
	insertAlongUV(0,Default_Median_End,0)
	setupProjection(0, scope.xz, 2,2,2,2,2)
	Cut_And_Fill_Reporting(Location)
	comp (f) {top:Raised_Curb_End_Extrusion(case Location == "Buffer":"Bikeways"  else:"Pedestrian",Dir)}
	
Raised_Curb_End_Extrusion(Mode,Dir)--> #Ground Textured Rule
	extrude(Sidewalk_Height)
	color( _ThematicRouter(Mode,case Mode == "Bikeways":"bike_buffer" else:"median"))
	texture(Sidewalk_Texture)
	projectUV(0)
	scaleUV(0, Sidewalk_Texture_Scale, Sidewalk_Texture_Scale)
	rotateUV(0, Sidewalk_Texture_Rotation)
	Delete_Texture

Raised_Curb_Forced_Ends(Location,Dir)-->
	Cut_And_Fill_Reporting(Location)
	Street_Lamp_Center(Location,Dir)
	split(u,unitSpace,0){geometry.dv(0,unitSpace)/2:rotateUV(0,180)Raised_Curb_End(Location,Dir) Asphalt(case Location=="Buffer":"Bikeways"else:"Pedestrian","asphalt")|#End Curb
						~1:split(v,unitSpace,0){ Curb_Depth:Curbs_Mass(false)ModeReporter((case Location=="Buffer":"Bikeways"else:"Pedestrian"))
							|~1:Street_Pavement(0,Location,Dir) ModeReporter((case Location=="Buffer":"Bikeways"else:"Pedestrian"))
							| Curb_Depth:Curbs_Mass(false)ModeReporter((case Location=="Buffer":"Bikeways"else:"Pedestrian"))}
						|geometry.dv(0,unitSpace)/2:Raised_Curb_End(Location,Dir) Asphalt(case Location=="Buffer":"Bikeways"else:"Pedestrian","asphalt")}#End Curb

						
Raised_Offset_Curb(Location,Dir,Mode,Setback)-->
	ModeReporter(Mode)
	Cut_And_Fill_Reporting(Location)
	Street_Lamp_Center(Location,Dir)
	split(v,unitSpace,0){Setback:Street_Pavement(0,"Median Offset",0)
		|~1:split(u,unitSpace,0){Setback:Street_Pavement(0,"Median Offset",0)
		|~1:Street_Pavement(0,"Median With Turn Lane",0)
		|Setback:Street_Pavement(0,"Median Offset",0)}
		|Setback:Street_Pavement(0,"Median Offset",0)} #Does not have all options for median, auto oriented median.


Street_Pavement(Boulevard_Side,Location,Dir)-->
#Boulevard side is used when arranging String=="None"
	case Location=="Buffer":
		extrude(world.y, Sidewalk_Height )
		comp(f){top=Buffer_Top}
	case Location=="Median":
		extrude(world.y, Sidewalk_Height )
		comp(f){top=Median_Top_Setup(Dir)}
	case Location=="Boulevard":
		extrude(world.y, Sidewalk_Height )
		comp(f){top=Boulevard_Top(Dir)	}
	case Location=="Boulevard Center":
		extrude(world.y, Sidewalk_Height )
		comp(f){top=Boulevard_Center_Top(Dir)	}
	case Location=="WalkWay_Right"||Location=="WalkWay_Left":
		WalkWay_Texture
		Master_Split(Boulevard_Side,(geometry.dv(0,unitSpace)>=Bench_Threshold_Width),"WalkWay",Dir)
		People
	case Location=="Open Space":
		extrude(world.y, Sidewalk_Height )
		comp(f){top=OpenSpace_Planting}
	case Location=="Median With Turn Lane":
		extrude(world.y, Sidewalk_Height )
		comp(f){top=Median_Plant_Side(0,Dir)} #Does not have all options for median, auto oriented median.
	case Location=="Median Offset":#Extruded sidewalk texture with sides. 
		extrude(world.y, Sidewalk_Height)
		comp(f) {top= General_Sidewalk_Texture
			|side= General_Sidewalk_Texture}
	else:
		extrude(world.y, Sidewalk_Height )
		WalkWay_Texture
		
General_Sidewalk_Texture--> #Ground Textured Rule	
	texture(Sidewalk_Texture)
	projectUV(0)
	scaleUV(0, Sidewalk_Texture_Scale, Sidewalk_Texture_Scale)
	rotateUV(0, Sidewalk_Texture_Rotation)
    set(material.metallic,1.0)
	Delete_Texture
	

Median_Top_Setup(Dir)-->
	case Dir==0:
		Median_Top(Dir)
	else:
		scaleUV(0,-1,1)
		Median_Top(Dir)		

Boulevard_Top(Dir)-->
	scaleUV(0,case Dir==2:-1 else:1,case Dir==2:-1 else:1)
	split(u, unitSpace,0){Median_Planting_Length+Median_Tree_Spacing:Main_Section_Construction(Dir)
						 |~_Bus_Furniture_Base("Boulevard","Far-side",Dir):Bus_Stop_Base("Boulevard",case Dir==0:180 else:0)
						 |~geometry.du(0,unitSpace)/2:Main_Section_Construction(Dir)
						 |~_Bus_Furniture_Base("Boulevard","Mid-Block",Dir):Bus_Stop_Base("Boulevard",case Dir==0:180 else:0)
						 |~geometry.du(0,unitSpace)/2:Main_Section_Construction(Dir)
						 |~_Bus_Furniture_Base("Boulevard","Near-side",Dir):Bus_Stop_Base("Boulevard",case Dir==0:180 else:0)
						 |Median_Planting_Length+Median_Tree_Spacing:Main_Section_Construction(Dir)}

Median_Top(Dir)-->
	split(u, unitSpace,0){Median_Planting_Length+Median_Tree_Spacing:Main_Section_Construction(Dir)
						 |~_Bus_Furniture_Base("Median","Far and Near Side",(case Median_Bus_Stop_Location=="Far-side":0 else: 2)):Bus_Stop_Base_Setup("Median",0)
						 |~geometry.du(0,unitSpace)/2:Main_Section_Construction(Dir)
						 |~_Bus_Furniture_Base("Median","Mid-Block",1):Bus_Stop_Base_Setup("Median",1)
						 |~geometry.du(0,unitSpace)/2:Main_Section_Construction(Dir)
						 |~_Bus_Furniture_Base("Median","Far and Near Side",(case Median_Bus_Stop_Location=="Far-side":2 else: 0)):Bus_Stop_Base_Setup("Median",2)
						 |Median_Planting_Length+Median_Tree_Spacing:Main_Section_Construction(Dir)}						 

Boulevard_Center_Top(Dir)-->
	case Boulevard_Center_Type=="Median":
		Main_Section_Construction(Dir) # Does not construct bus stop-walkways/plantings only. 
	else:
		Buffer_Texture
		
Bus_Stop_Base_Setup(Location,Stop_Number)-->#The Bus Stop, Bike Racks, and WayFinder are put here. 
	case Median_Bus_Stop_Location=="Mid-Block":
		split(v,unitSpace,0){'_Median_Midblock_Switch(0,"WalkWay"):WalkWay_Texture
							|'_Median_Midblock_Switch(0,"BusStop"):Bus_Stop_Base(Location,0)
							|'_Median_Midblock_Switch(2,"BusStop"):Bus_Stop_Base(Location,180)
							|'_Median_Midblock_Switch(2,"WalkWay"):WalkWay_Texture}
	case Median_Bus_Stop_Location=="Near-side":
		case Stop_Number==0:
			split(v,unitSpace,0){'.5:Bus_Stop_Base(Location,0)
								|'.5:WalkWay_Texture}
		else:
			split(v,unitSpace,0){'.5:WalkWay_Texture
								|'.5:Bus_Stop_Base(Location,180)}
	else:
		case Stop_Number==0:
			split(v,unitSpace,0){'.5:WalkWay_Texture
								|'.5:Bus_Stop_Base(Location,180)}
		else:
			split(v,unitSpace,0){'.5:Bus_Stop_Base(Location,0)
								|'.5:WalkWay_Texture}

Main_Section_Construction(Boulevard_Side)--># Rename Walkway_Right/Walk_WayLeft- DIR can replace it but is currently only used for benches. 
	case Planting_and_Walkway_Layout=="Plant:Walk":
		split(v,unitSpace,0){~1:Median_Plant_Side(Boulevard_Side,0)
							|WalkWay_Width:Street_Pavement(Boulevard_Side,"WalkWay_Left",2)}
	case Planting_and_Walkway_Layout=="Walk:Plant":
		split(v,unitSpace,0){WalkWay_Width:Street_Pavement(Boulevard_Side,"WalkWay_Right",0)
							|~1:Median_Plant_Side(Boulevard_Side,2)}
	case Planting_and_Walkway_Layout=="Plant:Walk:Plant":
		split(v,unitSpace,0){~1:Median_Plant_Side(Boulevard_Side,2)
							|WalkWay_Width:Street_Pavement(Boulevard_Side,"WalkWay_Left",2)
							|WalkWay_Width:Street_Pavement(Boulevard_Side,"WalkWay_Right",0)
							|~1:Median_Plant_Side(Boulevard_Side,0)}
	case Planting_and_Walkway_Layout=="Walk:Plant:Walk":
		split(v,unitSpace,0){WalkWay_Width:Street_Pavement(Boulevard_Side,"WalkWay_Right",0)
							|~1:Median_Plant_Side(Boulevard_Side,0)
							|WalkWay_Width:Street_Pavement(Boulevard_Side,"WalkWay_Left",2)}
	else:
		Median_Plant_Side(Boulevard_Side,0)

Median_Plant_Side(Boulevard_Side,Dir)-->
	split(u,unitSpace,0){{~Median_Tree_Spacing/2:WalkWay_Texture 
						|~Median_Planting_Length:Median_Plant_Base 
						|~Median_Tree_Spacing/2:WalkWay_Texture }*}

Bus_Stop_Base(Location,RotationAng)-->
	case Location=="Median":
		WalkWay_Texture
		Median_Object_Split(RotationAng)
	
	case Location=="Boulevard":
		WalkWay_Texture
		Boulevard_Object_Split(RotationAng)
		
	else:
		WalkWay_Texture
		Sidewalk_Object_Split(RotationAng)
		
Median_Object_Split(RotationAng)-->
	split(u,unitSpace,0){'_Bus_Alloc("Median"):Bus_Stop_Insert("Bus Stop",Bus_Stop_Object,RotationAng+90,.5)
						|'_Bike_Rack_Alloc("Median"):Bike_Rack_Split(RotationAng,0)
						|'_WayFinder_Alloc("Median"): Bus_Objects_Insert("Wayfinder",Wayfinder_Object,RotationAng,-.5,.3,3,1.2)}
	
Boulevard_Object_Split(RotationAng)-->
	split(u,unitSpace,0){'_Bus_Alloc("Boulevard"):Bus_Stop_Insert("Bus Stop",Bus_Stop_Object,RotationAng+90,.5)
						|'_Bike_Rack_Alloc("Boulevard"):Bike_Rack_Split(RotationAng,0)
						|'_WayFinder_Alloc("Boulevard"):Bus_Objects_Insert("Wayfinder",Wayfinder_Object,RotationAng,-.5,.3,3,1.2)}
					
Bus_Stop_Insert(Object_Identity,File_Extension,RotationAng,Translation)-->
		alignScopeToAxes(y)
		alignScopeToGeometry(yUp, largest, 1)
		rotateScope(0,RotationAng,0)
		s(0,0,0)
		center(xz)
		t(0,0,Translation)
		report("Objects."+Object_Identity+" Count",1)
		i(File_Extension)
		set(material.name,str(Object_Identity))
		Delete_Texture
		
Bus_Objects_Insert(Object_Identity,File_Extension,RotationAng,Translation,SX,SY,SZ)-->#Bus Object Constructor Method
		alignScopeToAxes(y)
		alignScopeToGeometry(yUp, largest, 1)
		rotateScope(0,RotationAng,0)
		t(Translation,0,0)
		report("Objects."+Object_Identity+" Count",1)
		s(SX,SY,SZ)
		center(xz)
		i(File_Extension)
		set(material.name,str(Object_Identity))
		Delete_Texture
		
Bike_Rack_Split(RotationAng,Translation)-->
	split(v,unitSpace,0){~1:NIL
						|.7:Bus_Objects_Insert("Bike Rack",Bike_Rack_Object,RotationAng,Translation,.1,1,.3)
						|.7:Bus_Objects_Insert("Bike Rack",Bike_Rack_Object,RotationAng,Translation,.1,1,.3)
						|~1:NIL}

Median_Plant_Base-->
	case Median_Ground_Cover =="None":
		WalkWay_Texture
	else:
		Planting_Curb(Median_Tree_Spacing)
		Tree_Setup("Median", Median_Tree_1_Percentage , Median_Tree_1_Type,Median_Tree_2_Type, Median_Tree_1_Height, Median_Tree_2_Height )
		Median_Planting

Median_Planting-->
	case Median_Ground_Cover =="Random":
		tileUV(0,2,2) texture(Random_Grass)
		Pervious_Reporting
	else:
		tileUV(0,2,2)texture(GrassFolder+"/"+ Median_Ground_Cover + ".jpg")
		Pervious_Reporting

OpenSpace_Planting-->
	scatter(surface,geometry.du(0,unitSpace)/3,uniform) { Tree_Setup("Median", Median_Tree_1_Percentage , Median_Tree_1_Type,Median_Tree_2_Type, Median_Tree_1_Height, Median_Tree_2_Height ) }
	tileUV(0,2,2) texture(Random_Grass)
	Pervious_Reporting
	
WalkWay_Texture--> #Ground Textured Rule
	tileUV(0,Sidewalk_Tile_Size,Sidewalk_Tile_Size) texture(Sidewalk_Texture)
	scaleUV(0, Sidewalk_Texture_Scale, Sidewalk_Texture_Scale)
	rotateUV(0, Sidewalk_Texture_Rotation)
	color( _ThematicRouter ("Pedestrian","median"))#If Display Thematics==Usage, goes to usage, if not, Thematic. 
	report("Center.Median Walkway Area (m^2)",geometry.area())
	Delete_Texture
#Object Loading Insertion
Master_Split(Boulevard_Side,Start_Condition, Location,Dir)-->#The Bus Stop, Bike Racks, and WayFinder are put here. 
	case Start_Condition:
		case Boulevard_Side==2:
		split(u,unitSpace,0){~Median_Bench_Spacing/2:NIL| {~2:Bench_Rule(Boulevard_Side,Dir)}|~Median_Bench_Spacing/2:NIL}*
		else: 
		split(u,unitSpace,0){~Median_Bench_Spacing/2:NIL| {~2:Bench_Rule(Boulevard_Side,Dir)}|~Median_Bench_Spacing/2:NIL}*
	else:
		NIL	

Bench_Rule(Boulevard_Side,Dir)-->  # DEAL WITH BUSTOP ANOTHER WAY_ DO A SPLIT THAT GROWS
		case Center_Type=="Boulevard":
			alignScopeToAxes(y)
			alignScopeToGeometry(yUp, largest, Boulevard_Side)#Side corresponds to appropriate edge selection
			Median_Bench_Rotator (Dir)
		else:
			alignScopeToAxes(y)
			alignScopeToGeometry(yUp, largest, 0)
			Median_Bench_Rotator (Dir)

Median_Bench_Rotator (Dir)-->
	case Dir==2:
		rotateScope(0,0,0)
		Median_Bench_Insert (Dir)
	else: 
		rotateScope(0,180,0)
		Median_Bench_Insert (Dir)		

Median_Bench_Insert (Dir)-->
	case Dir==2 && (Median_Benches=="Both"||Median_Benches=="Left"):
		s(0,0,0)
		center(xz)
		t(-WalkWay_Width/2+Bench_Adjuster,0,0)
		Bench_Insert
	case Dir==0 && (Median_Benches=="Both"||Median_Benches=="Right"):
		s(0,0,0)
		center(xz)
		t(-WalkWay_Width/2+Bench_Adjuster,0,0)
		Bench_Insert
	else:
		NIL

Street_Lamp_Center(Location,Dir)-->
	case Location=="Boulevard":
		scaleUV(0,case Dir==2:-1 else:1,case Dir==2:-1 else:1)
		split(u,unitSpace,0) {~ Median_Street_Lamp_Spacing :NIL
							 |{1:Street_Lamp_Sider(Dir)
							 |~ Median_Street_Lamp_Spacing :NIL}*}
 	case Location=="Median":
 		scaleUV(0,case Dir==2:-1 else:1,case Dir==2:-1 else:1)
 		split(u,unitSpace,0) {~ Median_Street_Lamp_Spacing:NIL
							 |{1:Street_Lamp_Sider(0) #Median Dir should be set to 0 to grab right edge
							 |~ Median_Street_Lamp_Spacing :NIL}*}
	else:
		NIL

Street_Lamp_Sider(Dir)-->
	case Median_Street_Lamps =="Both":
		split(v,unitSpace,0) {.5:Lamp_Center_Asset(180,case Dir==0:0 else:2,Dir,Median_Street_Lamp_Offset)
							 |~1:NIL
							 |.5:Lamp_Center_Asset(-90,case Dir==0:5 else:3,Dir,-Median_Street_Lamp_Offset)}
	case Median_Street_Lamps =="Right":
		split(v,unitSpace,0) {~1:NIL
							 |.5:Lamp_Center_Asset(-90,case Dir==0:5 else:3,Dir,-Median_Street_Lamp_Offset)}
	case Median_Street_Lamps =="Left":
		split(v,unitSpace,0) {.5:Lamp_Center_Asset(180,case Dir==0:0 else:2,Dir,Median_Street_Lamp_Offset)
							 |~1:NIL}
	else:
		NIL
Lamp_Center_Asset(Side_Rotation,Shape_Edge,Dir,Offset)-->
	alignScopeToGeometry(yUp, largest,Shape_Edge)
	alignScopeToAxes(y)		// place the Lamps vertically
	center(xz)
	s(0,0,0)				//set initital height to 5 others are based on OBJ
	r(0,Side_Rotation,0)
	t(Offset,0,0)
	report("Objects.Street Lamp Count", 1)
	color( _ThematicRouter ("Pedestrian","lamp"))
	label("Street Lamp")
	i(Street_Lamp_Object)
	set(material.name,str("Street_Lamp"))
	Delete_Texture
	
##########################################
#Tree Loader Code
Median_TreeSplit-->
#color(rand(1),rand(1),rand(1))
	split(u,unitSpace,0){{~Median_Tree_Spacing/2:NIL
						 |1:Tree_Setup("Median", Median_Tree_1_Percentage , Median_Tree_1_Type, Median_Tree_2_Type,Median_Tree_1_Height,Median_Tree_2_Height)
						 |~Median_Tree_Spacing/2:NIL}*}

Tree_Setup(Location,Percentage1,Tree_Type1,Tree_Type2,Tree_Height1,Tree_Height2)-->	                     				
		s(0,0,0)       // set scope
		r(scopeCenter, 0,rand(0,360),0)// random rotate
		set(material.name,"Planting")
		alignScopeToAxes(y)
		center(xz)
		Tree_Location_Setup(Location,Percentage1,Tree_Type1,Tree_Type2,Tree_Height1,Tree_Height2)	
Tree_Location_Setup(Location,Percentage1,Tree_Type1,Tree_Type2,Tree_Height1,Tree_Height2)-->
	case Location == "Median":
		Median_Tree_Insert_Setup(Location,Percentage1,Tree_Type1,Tree_Type2,Tree_Height1,Tree_Height2)
	else:
		Sidewalk_Tree_Insert_Setup(Location,Percentage1,Tree_Type1,Tree_Type2,Tree_Height1,Tree_Height2)

Median_Tree_Insert_Setup(Location,Percentage1,Tree_Type1,Tree_Type2,Tree_Height1,Tree_Height2)-->
	case p(Percentage1):
		Median_Tree_Insert_Setup_1(Location,Tree_Type1,Tree_Height1)
	case Tree_Type2!="None": #So if the percentage if 50%, and Tree1 does not fire, if tree 2 is not set to None, that tree 2 will be selected.
		Median_Tree_Insert_Setup_2(Location,Tree_Type2,Tree_Height2)
	else:
		NIL
Sidewalk_Tree_Insert_Setup(Location,Percentage1,Tree_Type1,Tree_Type2,Tree_Height1,Tree_Height2)-->
	case p(Percentage1):
		Sidewalk_Tree_Insert_Setup_1(Location,Tree_Type1,Tree_Height1)
	case Tree_Type2!="None": #So if the percentage if 50%, and Tree1 does not fire, if tree 2 is not set to None, that tree 2 will be selected.
		Sidewalk_Tree_Insert_Setup_2(Location,Tree_Type2,Tree_Height2)
	else:
		NIL

Median_Tree_Insert_Setup_1(Location,Tree_Type,Tree_Height)-->
	Tree_Insert_Type(Location,Tree_Type,_DeviateValue(Tree_Height,Median_Tree_Height_Deviation))

Median_Tree_Insert_Setup_2(Location,Tree_Type,Tree_Height)-->
	Tree_Insert_Type(Location,Tree_Type,_DeviateValue(Tree_Height,Median_Tree_Height_Deviation))

Sidewalk_Tree_Insert_Setup_1(Location,Tree_Type,Tree_Height)-->
	Tree_Insert_Type(Location,Tree_Type,_DeviateValue(Tree_Height,Sidewalk_Tree_Height_Deviation))
	
Sidewalk_Tree_Insert_Setup_2(Location,Tree_Type,Tree_Height)-->
	Tree_Insert_Type(Location,Tree_Type,_DeviateValue(Tree_Height,Sidewalk_Tree_Height_Deviation))
	
			
Tree_Insert_Type(Location,Tree_Type1,Tree_Height1)-->
	case Tree_Height1<.001: #If Tree Height is reduced beyond a limit, remove tree. 
		NIL
	case texturingOn:
		s(0,0,0)
		report("Vegetation.Construction, Tree Cost",TreeCostAverage)
		set(Tree.Name, Tree_Type_Adjusted(Tree_Type1))
		set(Tree.Height, Tree_Height1)
		set(Tree.Radius,Tree_Radius(Tree_Type1,Tree_Height1))
		Tree.Generate
	else: #If Texturing is off, the tree texture is overrided to the current thematic color 
		s(0,0,0)
		report("Vegetation.Construction, Tree Cost",TreeCostAverage)
		set(Tree.Name, Tree_Type_Adjusted(Tree_Type1))
		set(Tree.Height, Tree_Height1)
		set(Tree.Radius,Tree_Radius(Tree_Type1,Tree_Height1))
		set(Tree.OverwriteColor, _ThematicRouter ("Plantings","vegetation"))
		Tree.Generate

	
	
Tree_Type_Adjusted(Tree_Type) = 
	case Tree_Type == "Random": randomTreeType
	else: Tree_Type

randomTreeType = 
	25%:	 "White Ash"
	25%:	 "Red Hickory"
	25%:	 "Sweetgum"
	else:	 "Sassafras"
###################################################

###################################################
# Crosswalk
#

Crosswalk(crosswalkType,uvSet) -->
	report("Crosswalk.Crosswalk Area",geometry.area())
	NoGeometryModeReporter("Conflict Zones")
	color( _ThematicRouter ("Conflict Zones","crosswalk"))
	CrosswalkDirector(crosswalkType,uvSet)
	
CrosswalkDirector(crosswalkType,uvSet)-->
	case crosswalkType == "transverse"	 : CrosswalkTransverse(uvSet)
	case crosswalkType == "dashed"    	 : CrosswalkDashed(uvSet)
	case crosswalkType == "ladder"    	 : CrosswalkLadder(uvSet)
	case crosswalkType == "solid"     	 : AsphaltPainted(Crosswalk_Color,"Conflict Zones","crosswalk")
	case crosswalkType == "custom"	 	 : CrosswalkWalkway(true)
	case crosswalkType == "ladder custom": CrosswalkLadderWalkway(uvSet)
	case crosswalkType == "raised custom": CrosswalkRaised(uvSet)
	else							     : CrosswalkContintental

CrosswalkContintental -->
	split(v,uvSpace,0){ (ceil(geometry.vMin-0.01)-geometry.vMin): Asphalt("Conflict Zones","crosswalk")
					  | ~1: CrosswalkStripes(1)
					  | geometry.vMax-floor(geometry.vMax+0.01): Asphalt("Conflict Zones","crosswalk") }

CrosswalkLadder(uvSet) -->
	split(u,uvSpace,uvSet){ 0.17: AsphaltPainted( Crosswalk_Color,"Conflict Zones","crosswalk") 
						  | ~1  : CrosswalkStripes(1)
						  | 0.17: AsphaltPainted( Crosswalk_Color ,"Conflict Zones","crosswalk")}	

CrosswalkTransverse(uvSet) -->
	split(u,uvSpace,uvSet){ 0.27: AsphaltPainted( Crosswalk_Color ,"Conflict Zones","crosswalk") 
						  | ~1  : Asphalt("Conflict Zones","crosswalk")
						  | 0.27: AsphaltPainted( Crosswalk_Color ,"Conflict Zones","crosswalk")}

CrosswalkLadderWalkway(uvSet)-->
	split(u,uvSpace,uvSet){ 0.27: AsphaltPainted( Crosswalk_Color,"Conflict Zones","crosswalk") 
						  | ~1  : CrosswalkWalkway(false)
						  | 0.27: AsphaltPainted( Crosswalk_Color,"Conflict Zones","crosswalk")}	
CrosswalkDashed(uvSet) -->
	split(u,uvSpace,uvSet){ 0.17: CrosswalkStripes(0.6) 
						  | ~1  : Asphalt("Conflict Zones","crosswalk")
						  | 0.17: CrosswalkStripes(0.6) }	

CrosswalkStripes(stripeWidth) --> #Ground Textured Rule
	case !Not_Low_LOD:
		cleanupGeometry(all, 0.001) 
		tileUV(0,0,~1) scaleUV(0,1,1/8/stripeWidth) 		# to setup the v-direction: a continental crosswalk line is 1m width, and the texture contains 8 of these.
		texture(LanesFolder + "/crosswalk_continental_"+ Crosswalk_Color +".jpg")
		Delete_Texture
	else:
		cleanupGeometry(all, 0.001) 
		split(v,unitSpace,0) {ThickPaintLineWidth:Asphalt("Conflict Zones","crosswalk")|
		                     {ThickPaintLineWidth:AsphaltPainted( Crosswalk_Color,"Conflict Zones","crosswalk")|
							ThickPaintLineWidth:Asphalt("Conflict Zones","crosswalk")}*}

	
CrosswalkWalkway(reporting)--> #Ground Textured Rule
	case reporting:
		tileUV(0,Sidewalk_Tile_Size,Sidewalk_Tile_Size) texture(Custom_Crosswalk_Texture)
		Delete_Texture
	else:
		tileUV(0,Sidewalk_Tile_Size,Sidewalk_Tile_Size) texture(Custom_Crosswalk_Texture)
		Delete_Texture
		
CrosswalkRaised(uvSet)-->
	split(u,uvSpace,uvSet){ 0.4: Insert_Slope(Sidewalk_Height,case uvSet==1:180 else: 0)
						  | ~1  : extrude(Sidewalk_Height) CrosswalkWalkway(false)
						  | 0.4: Insert_Slope(Sidewalk_Height,case uvSet==1:0 else: 180)}

Insert_Slope(height,rotation)-->
	rotateUV(0,rotation)
    normalizeUV(0, uv, collectiveAllFaces)
	alignScopeToAxes(y)
	insertAlongUV(0,Default_Wedge,height)
	setupProjection (0,scope.yz, 2, 2, 2, 2,1)
	texture(Custom_Crosswalk_Texture)
	projectUV(0)
	Delete_Texture
###################################################
# Other default Start Rules of the graph
#
#Many are only sent to Asphalt. This includes joints, crossings, and junctions. 
# drive-through street segments
@StartRule
Joint-->
	set(material.opacity,1-Transparency)
	set(material.name,"Road_Bed_Joint")
	BridgeMain
	report("Connection Shape Area.Joint Area",geometry.area())#Only reports given to Joints
	Asphalt("Auto","asphalt")
@StartRule
Junction --> 
	set(material.opacity,1-Transparency)
	set(material.name,"Road_Bed_Junction")
	BridgeMain
	report("Connection Shape Area.Intersection Area",geometry.area())
	Asphalt("Auto","asphalt")
@StartRule
Freeway -->
	set(material.opacity,1-Transparency)
	set(material.name,"Road_Bed_Freeway")
	report("Connection Shape Area.Freeway Area",geometry.area())#Only reports given to freeways. 
	set(streetWidth,geometry.dv(0,unitSpace))
	set( Lane_Width ,streetWidth/geometry.dv(0,uvSpace))
	split(v,unitSpace,0){ {Lane_Width       : MainLaneMarkingLODChoice(0,split.index,"_stripes_white")}* 
						|~Lane_Width :Asphalt("Auto","drive_lane")}
# 	MixedTrafficOnLane (0,split.index,nLanesTotal)
	BridgeMain
# crossing is just Asphalt for now
@StartRule
Crossing -->
	set(material.opacity,1-Transparency)
	set(material.name,"Road_Bed_Crossing")
	BridgeMain
	report("Connection Shape Area.Crossing Area", geometry.area())#Only reports given to crossings
	Asphalt("Auto","asphalt")
# freeway entries have an additional striped line (splits the shape into lanes but also splits away a shape just for the striped line using special UVSET 1
@StartRule
FreewayEntry -->
	set(material.opacity,1-Transparency)
	set(material.name,"Road_Bed_FreewayEntry")
	report("Connection Shape Area.Freeway Entry Area",geometry.area())#Only reports given to freeways. 
	set(streetWidth,geometry.dv(0,unitSpace))
	set(Lane_Width ,streetWidth/geometry.dv(0,uvSpace))
	split(v,unitSpace,1){{Lane_Width      : MainLaneMarkingLODChoice(0,split.index,"_stripes_white")}* 
						|~Lane_Width :Asphalt("Auto","asphalt")}

	BridgeMain


###################################################
# Roundabout
#
@StartRule
Roundabout   --> 
	case valency>1: 
		set(material.opacity,1-Transparency)
		set(material.name,"Road_Bed_Roundabout")
		Asphalt("Auto","asphalt") 
		BridgeMain#split(v,unitSpace,0){ 1: MainLaneMarkings(0,split.index,"_stripes_white") }* 
	else		  : 
		set(material.opacity,1-Transparency) 
		set(material.name,"Road_Bed_Roundabout")
		Asphalt("Auto","asphalt") 
		BridgeMain							# cul-de-sac is Asphalt only
@StartRule
RoundaboutIsland --> 
	case Sidewalk_Ground_Cover !="None": 
		set(material.opacity,1-Transparency)
		set(material.name,"Road_Bed_Roundabout") 
		IslandWithGreen 
		BridgeMain
	else		  : 
		set(material.opacity,1-Transparency) 
		set(material.name,"Road_Bed_Roundabout")
		Asphalt("Auto","asphalt")	
		BridgeMain# cul-de-sac is Asphalt only
@StartRule
IslandWithGreen -->
	offset(- Sidewalk_Height )
	comp(f){ inside: Tree_Scatter
		   | border: setupProjection(0,scope.xy,'1,'1) projectUV(0) Curbs_Mass(false) }

Green --> #Ground Textured Rule
	translate(rel,world,0, Sidewalk_Height ,0)
	setupProjection(0,scope.yx,2,2) projectUV(0)
	texture(Random_Grass)
	Pervious_Reporting
	
Tree_Scatter-->
	scatter(surface,3,gaussian,center,'2) { Tree_Setup("Round About", Sidewalk_Tree_1_Percentage ,Sidewalk_Tree_1_Type,Sidewalk_Tree_2_Type, Sidewalk_Tree_1_Height, Sidewalk_Tree_2_Height) }
	Green

###################################################
# Sidewalk
#
@StartRule
Sidewalk-->
	set(material.name,"Road_Bed_Sidewalk")
	Initial_Sidewalk_Settings
	
Initial_Sidewalk_Settings-->
	case Specularity==1 && Transparency==0:
		Sidewalk_Generation
	else:
		Sidewalk_Generation_Altered
		
Sidewalk_Generation_Altered-->		
	case Transparency>0 && Specularity==1:
		set(material.opacity,1-Transparency)
		Sidewalk_Generation
	else:
		set(material.specular.g,Specularity)
		set(material.specular.b,Specularity)
		set(material.specular.r,Specularity)
		Sidewalk_Generation
		
Sidewalk_Generation-->
	BridgeSide
	set(sidewalkWidth,scope.sz)
	set(sidewalkLength,scope.sx)
	setupProjection(0,scope.xz,2,2,0,0,1)
# 	setupProjection(5,scope.xz,2,2,0,0,1)
# 	setupProjection(7,scope.xz,2,2,0,0,1)
# 	setupProjection(8,scope.xz,2,2,0,0,1)
	color( _ThematicRouter ("Pedestrian","sidewalk"))#If Display Thematics==Usage, goes to usage, if not, Thematic. 
	report("Cut/Fill.Total Sidewalk Cut/Fill Volume (m^3)", geometry.area()*Sidewalk_Height)
	split(v,unitSpace,0){Curb_Depth*Curb_Switch: Curbs_Mass(false) 
						| ~1: Sidewalk_Setup }
	Enclose_Shape #Enclose Shapes for Printing
	ModeReporter("Pedestrian")


Curbs_Mass(RotateUV)-->
	extrude(world.y, Sidewalk_Height )
	comp(f) {top:Curbs(RotateUV)|side:Curbs(false)}
	
Curbs_Mass(RotateUV,Height)--> #Overload Curbs_Mass
	extrude(world.y, Height)
	comp(f) {top:Curbs(RotateUV)|side:Curbs(false)}


Curbs(RotateUV) --> #Ground Textured Rule 
  	case RotateUV:#Used to handle an exception where scope changes on horizontal curbs (parallel to crosswalk)
  		rotateUV(0,270) 
  		setupProjection(0,scope.yx,~2,'1)#Notice axis choice changed. 
  		texture(SidewalkFolder+"/curbs_2m.jpg")
  		projectUV(0)
  		Delete_Texture	
  	else:		
  		setupProjection(0,scope.xy,~2,'1)
  		texture(SidewalkFolder+"/curbs_2m.jpg")
  		projectUV(0)
  		Delete_Texture
  		
Sidewalk_Setup-->
	case sidewalkSide=="Right":
		extrude(world.y, Sidewalk_Height )
		comp(f){top=SidewalkTop(sidewalkSide)|side: Sidewalk_Pavement("Building Side") }
	case sidewalkSide=="Left":
		scaleUV(0,1,1)
		extrude(world.y, Sidewalk_Height ) 
		comp(f){top=SidewalkTop(sidewalkSide)|side: Sidewalk_Pavement("Building Side") }
	else:
		print("Error: two right sidewalks as default- please map this attribute.") 
		extrude(world.y, Sidewalk_Height ) 
		comp(f){top=SidewalkTop(sidewalkSide)|side: Sidewalk_Pavement("Building Side") }

SidewalkTop(side)-->
	case valency>1:
		Sidewalk_Pavement("Corners")
	case Sidewalk_Ground_Cover =="None":
		split(v,unitSpace,0) {_Side_Sidewalk_Furniture_Zone_Width(side):Sign_Loader(side)
							|_Side_Sidewalk_Planting_Width(side):Sidewalk_WOPlant_Loading_Section (case side=="Right":0 else:2)# Uses a different loading section rule
							|_Sidewalk_BikeLane_Width(case side=="Right":0 else: 2)	:Sidewalk_Bike_Lane_Loader(case side=="Right":0 else: 2)
							|~1: Sidewalk_Pavement("Through Zone") People}
	else:
		split(v,unitSpace,0){_Side_Sidewalk_Furniture_Zone_Width(side):Sign_Loader(side)
							|_Side_Sidewalk_Planting_Width(side): Sidewalk_WPlant_Loading_Section (case side=="Right":0 else:2)
							|_Sidewalk_BikeLane_Width(case side=="Right":0 else: 2)	:Sidewalk_Bike_Lane_Loader(case side=="Right":0 else: 2)
							|~1: Sidewalk_Pavement("Through Zone") People}

Sign_Loader(side)-->
	Sidewalk_Pavement("Sign Gap")
	Traffic_Light_Setup
	Parking_Meter_Setup
	Sidewalk_Lamp_Setup
	
Sidewalk_Lamp_Setup -->
	case Sidewalk_Street_Lamps =="None":
		NIL
	case sidewalkSide=="Right":
		case Sidewalk_Street_Lamps =="Right" || Sidewalk_Street_Lamps =="Both":
			split(u,unitSpace,0) {~ Sidewalk_Street_Lamp_Spacing :NIL
								 |{.1: Sidewalk_Lamp (Sidewalk_Street_Lamp_Offset)
								 |~ Sidewalk_Street_Lamp_Spacing :NIL}*}
		else: 
			NIL
	case sidewalkSide=="Left":
		case Sidewalk_Street_Lamps =="Left" || Sidewalk_Street_Lamps =="Both":
			split(u,unitSpace,0) {~ Sidewalk_Street_Lamp_Spacing :NIL
								 |{.1: Sidewalk_Lamp (Sidewalk_Street_Lamp_Offset)
								 |~ Sidewalk_Street_Lamp_Spacing :NIL}*}
		else: 
			NIL
	else:
		NIL
Traffic_Light_Setup-->
	case Traffic_Lights=="None":
		NIL
	case sidewalkSide=="Right":
		case Traffic_Lights=="Right" || Traffic_Lights=="Both":
			scaleUV(0,DirectionalFlip,1)
			split(u,unitSpace,0) {_crosswalkEndWidth-3.5:NIL #-3.5 is so that if if the crosswalk is short its just placed at the end of the sidewalk-handles up to 9 m crosswalks well.
								 |1:Traffic_Light(0)
								 |~1:NIL}
		else: 
			NIL
	case sidewalkSide=="Left":
		case Traffic_Lights=="Left" || Traffic_Lights=="Both":
			scaleUV(0,DirectionalFlip,1)
			split(u,unitSpace,0) {_crosswalkEndWidth-3.5:NIL #-3.5 is so that if if the crosswalk is short its just placed at the end of the sidewalk-handles up to 9 m crosswalks well.
								 |1:Traffic_Light(2)
								 |~1:NIL}
		else: 
			NIL
	else:
		NIL

Traffic_Light(index)-->
	alignScopeToAxes(y)		// place the Lamps vertically
	t(TLight_Translate_X,0,-TLight_Translate_Z)
	s(0,0,0)				// set height to 5 meters
	Traffic_Light_Asset(index)

Traffic_Light_Asset(index)-->
	t(0,0,-0.1)
	r(0,Traffic_Light_Rotation,0)
	set(material.name,"Traffic_Light")
	report("Objects.Traffic Lights Count", 1)
	i(Traffic_Light_Object)
	label("Traffic Light")
	color( _ThematicRouter ("Pedestrian","traffic_light"))
	Delete_Texture
	
Sidewalk_Lamp(offset) -->
	alignScopeToGeometry(yUp,largest,0)
	alignScopeToAxes(y)		// place the Lamps vertically
	center(xz)
	r(0,90,0)
	s(0,0,0)				// set height to 5 meters
	report("Objects.Street Lamp Count", 1)
	LampAsset(offset)		// since the scope's dimenstion are zero in x and z, these are set according to the asset
	
LampAsset(offset) -->
	t( SLight_Translate_X ,0, SLight_Translate_Z )
	r(0,90,0)
	t(offset,0,0)
	set(material.name,"Street_Lamp")
	label("Street Lamp")
	color( _ThematicRouter ("Pedestrian","lamp"))
	i(Street_Lamp_Object)
	Delete_Texture

Parking_Meter_Setup-->
	case Parking_Meters=="None":
		NIL
	case sidewalkSide=="Right":
		case Parking_Meters=="Right" || Parking_Meters=="Both":
			Parking_Meter_Loader(Right_Parking_Length,0)
			
		else: 
			NIL
	case sidewalkSide=="Left":
		case Parking_Meters=="Left" || Parking_Meters=="Both":
			Parking_Meter_Loader(Left_Parking_Length,2)
		else: 
			NIL
	else:
		NIL

Parking_Meter_Loader(Parking_Length,Dir)-->
	split(u,unitSpace,0) {(_Sidewalk_CrossStop_Gap(Dir,"Begin") + Parking_Meter_Setback):NIL # moves starting point for meters into near middle
						 |{.25:Sign_Objects_Insert("Parking Meter",Parking_Meter_Object,0,0,.3,1.4,.3)
						 |~Parking_Meters_Spacing:NIL}*
						 |(_Sidewalk_CrossStop_Gap(Dir,"End")):NIL}

Sidewalk_Pavement(Location) --> #Ground Textured Rule
	case Location== "Through Zone" || Location=="Corners":
		report("Sidewalk."+Location+" Area (m^2)",geometry.area())
		General_Sidewalk_Texture
	else:
		General_Sidewalk_Texture
	
		
Sidewalk_WPlant_Loading_Section (Dir)-->
	split(u,unitSpace,0){(_Sidewalk_CrossStop_Gap(Dir,"Begin")): Sidewalk_Pavement("Cross Walk Begin Gap")
						|~_Bus_Sidewalk_Base("Near-side"):Bus_Stop_Base("Sidewalk",0)
						|~geometry.du(0,unitSpace)/2:Sidewalk_Plant_Side("Begin")
						|~_Bus_Sidewalk_Base("Mid-Block"):Bus_Stop_Base("Sidewalk",0)
						|~geometry.du(0,unitSpace)/2:Sidewalk_Plant_Side("End")
						|~_Bus_Sidewalk_Base("Far-side"):Bus_Stop_Base("Sidewalk",0)
						|(_Sidewalk_CrossStop_Gap(Dir,"End") ): Sidewalk_Pavement("Cross Walk End Gap")}

Sidewalk_WOPlant_Loading_Section (Dir)-->
	split(u,unitSpace,0){(_Sidewalk_CrossStop_Gap(Dir,"Begin")): Sidewalk_Pavement("Cross Walk Begin Gap")People
						|~_Bus_Sidewalk_Base("Near-side"):Bus_Stop_Base("Sidewalk",0)
						|~geometry.du(0,unitSpace)/2: Sidewalk_Pavement("Through Zone")People
						|~_Bus_Sidewalk_Base("Mid-Block"):Bus_Stop_Base("Sidewalk",0)
						|~geometry.du(0,unitSpace)/2: Sidewalk_Pavement("Through Zone") People
						|~_Bus_Sidewalk_Base("Far-side"):Bus_Stop_Base("Sidewalk",0)
						|(_Sidewalk_CrossStop_Gap(Dir,"End") ): Sidewalk_Pavement("Cross Walk End Gap")People}

Sidewalk_Bike_Lane_Loader(Dir)-->
	split(u,unitSpace,0){~1:scaleUV(0,DirectionalFlip,1)BikeLaneSection(case Dir==0:-1 else:1,_Sidewalk_BikeLane_Width(Dir))}

Sidewalk_Object_Split(RotationAng)-->
	split(u,unitSpace,0){'_Bus_Alloc("Sidewalk"): Bus_Stop_Insert("Bus Stop",Bus_Stop_Object,RotationAng+90,Sidewalk_Bus_Stop_Setback)
						|'_Bike_Rack_Alloc("Sidewalk"):Bike_Rack_Split(RotationAng,0)
						|'_WayFinder_Alloc("Sidewalk"):Bus_Objects_Insert("Wayfinder",Wayfinder_Object,RotationAng,-.5,.3,3,0.5)}

Sidewalk_Plant_Side(Plant_Side_Base_Switch)-->
	split(u,unitSpace,0){~Sidewalk_Planting_Spacing /2: Sidewalk_Pavement("Before Planting")
						|~Sidewalk_Planting_Length:Plant_Base 
						|~Sidewalk_Planting_Spacing/2: Sidewalk_Pavement("After Planting") Sidewalk_Bench_Loader(split.index,split.total,Plant_Side_Base_Switch)}*	

Sidewalk_Bench_Loader(splitNum,splitTotal,Plant_Side_Base_Switch)-->
		case Sidewalk_Benches =="None":
		NIL
	case sidewalkSide=="Right" && (splitNum!=splitTotal-1 || Plant_Side_Base_Switch!="End"):#Does not place a bench on the end split of the End Sidewalk_Plant_Side_Base (if Switch is removed no bench is generated mid-block)
		case Sidewalk_Benches =="Right" || Sidewalk_Benches=="Both":
			Sidewalk_Bench_Insert(0,geometry.du(0,unitSpace))
		else: 
			NIL
	case sidewalkSide=="Left" && (splitNum!=splitTotal-1 || Plant_Side_Base_Switch!="End"): #Does not place a bench on the end
		case Sidewalk_Benches =="Left" || Sidewalk_Benches=="Both":
			Sidewalk_Bench_Insert(2,geometry.du(0,unitSpace))
		else: 
			NIL
	else:
		NIL

Sidewalk_Bench_Insert(Dir,geometry_Len)-->
	case geometry.du(0,unitSpace)>1.5: #Remember two gaps, so it is 2 (width of bench)/2
		alignScopeToAxes(y)
		alignScopeToGeometry(yUp, largest, 0)
		s(0,0,0)
		t(geometry_Len,0,(Sidewalk_Planting_Width/10)+.25)#When geometry.du is used functionality is different (alignment issue?) passed parameter works best likely because it is before scope manipulation (rotate etc)dv. might work instead.
		Sidewalk_Bench_Context_Check	
	else:
		NIL

Sidewalk_Bench_Context_Check-->
	case bool(Context_Aware_Queries) && ((_HasCurbsideManagement(Right_Parking_Type)+_HasCurbsideManagement(Left_Parking_Type))>=1):
		case minimumDistance("inter","curbside_managed_zone")>=Max_Distance_From_CS_Manage:
			Bench_Insert
		else:
			NIL
	else:
		Bench_Insert
		
Bench_Insert-->
	case SBench_Toggle:
 		t( SBench_Translate_X ,0, SBench_Translate_Z )
		i(Bench_Object)
		set(material.name,"Bench")
		label("Bench")
		Delete_Texture
	else:
		NIL
		
Plant_Base-->
case Sidewalk_Ground_Cover =="None":
	Sidewalk_Pavement("Plant_Space")
else:
	Curbside_Context_Planting_Allocation

Curbside_Context_Planting_Allocation-->
	case bool(Context_Aware_Queries) && ((_HasCurbsideManagement(Right_Parking_Type)+_HasCurbsideManagement(Left_Parking_Type))>=1):
		case minimumDistance("inter","curbside_managed_zone")>=Max_Distance_From_CS_Manage:
			Allocate_Planting_Area
		else:
			Sidewalk_Pavement("Plant_Space")
	else:
		Allocate_Planting_Area
	
Allocate_Planting_Area-->
	Planting_Curb(Sidewalk_Planting_Spacing)
	Sidewalk_Planting
	Tree_Setup("Sidewalk", Sidewalk_Tree_1_Percentage , Sidewalk_Tree_1_Type, Sidewalk_Tree_2_Type, Sidewalk_Tree_1_Height, Sidewalk_Tree_2_Height )
	
Sidewalk_Planting--> #Ground Textured Rule# THis is set up this way to support a vegetated buffer with no trees on sidewalk
		case Sidewalk_Ground_Cover =="None":
		tileUV(0,2,2) texture(Random_Grass)
		Pervious_Reporting
		case Sidewalk_Ground_Cover =="Random":
		tileUV(0,2,2) texture(Random_Grass)
		Pervious_Reporting
		else:
		tileUV(0,2,2)texture(GrassFolder+"/"+ Sidewalk_Ground_Cover + ".jpg")
		Pervious_Reporting
		
Planting_Curb(Planting_Spacing)-->
	case Sidewalk_Planting_Border == "Curb":
		split(u,unitSpace,0){Curb_Depth*_ContiguousPlantingSwitch(Planting_Spacing):Curbs_Mass(true,Sidewalk_Height/2)|
			~1:split(v,unitSpace,0){Curb_Depth*_ContiguousPlantingSwitch(Planting_Spacing):Curbs_Mass(false,Sidewalk_Height/2)|~1:NIL|Curb_Depth*_ContiguousPlantingSwitch(Planting_Spacing):Curbs_Mass(false,Sidewalk_Height/2)}|
		Curb_Depth*_ContiguousPlantingSwitch(Planting_Spacing):Curbs_Mass(true,Sidewalk_Height/2)}
	else:
		NIL
Sign_Objects_Insert(Object_Identity,File_Extension,RotationAng,Translation,SX,SY,SZ)-->#Sidewalk Object Constructor Rule
	alignScopeToAxes(y)
	alignScopeToGeometry(yUp, largest, 1)
	rotateScope(0,RotationAng,0)
	center(xz)
	t(scope.sx-SX,0,0)
	t(Translation,0,0)
	i(File_Extension)
	set(material.name,"Signs")
	label("Signs")
	s(SX,SY,SZ)
	report("Objects."+Object_Identity+" Count",1)
	Delete_Texture
##################################################
#Paint & Asphalt Reporting	
#Asphalt Painted is actually retrofitted to be the paint and mode reporting aggregator, all "Paint Areas" originate here. 
Asphalt(Usage,LabelID) --> #Ground Textured Rule
	tileUV(0,Asphalt_Tile_Size,Asphalt_Tile_Size)
	cleanupGeometry(all, 0.001)
	texture( LanesFolder+"/"+Asphalt_Base)
	ProjectPBRTextures(LanesFolder+"/"+Asphalt_Base,Usage,LabelID,true)
	
	
ProjectPBRTextures(path,Usage,LabelID,Report)-->
	case Not_Low_LOD:
		setupProjection(5,scope.xz,_TextureDimensionByUsage(Usage),_TextureDimensionByUsage(Usage),0,0,1)
		setupProjection(7,scope.xz,_TextureDimensionByUsage(Usage),_TextureDimensionByUsage(Usage),0,0,1)
		setupProjection(8,scope.xz,_TextureDimensionByUsage(Usage),_TextureDimensionByUsage(Usage),0,0,1)
		ApplyPBRTextures(path,Usage,LabelID,Report)
	else:
		ReportManager(Usage,LabelID,Report)

	
ApplyPBRTextures(path,Usage,LabelID,Report)-->
	case Not_Low_LOD:
		set(material.shader,"CityEnginePBRShader")
		set(material.normalmap,_Construct_PBR_Path(path,"norm"))
		projectUV(5)
		set(material.roughnessmap,_Construct_PBR_Path(path,"roug"))
		projectUV(8)
		set(material.occlusionmap, _Construct_PBR_Path(path,"aocc"))
		projectUV(7)
		ReportManager(Usage,LabelID,Report)
	else:
		NIL

AsphaltPainted(paintColor,Usage,LabelID) --> #Ground Textured Rule
	case paintColor!="black":# This makes sure that if the color is black, it is thrown into Asphalt Reporting
		tileUV(0,Asphalt_Tile_Size,Asphalt_Tile_Size)
		cleanupGeometry(all,0.001)
		texture(LanesFolder+"/Asphalt003_2K_" + paintColor + "_Color.jpg")
		set(material.name,str(material.name)+"_"+str(paintColor))
		ProjectPBRTextures(LanesFolder+"/"+Asphalt_Base,Usage,LabelID,true)
	else:#If Black redirect to asphalt rule.
		Asphalt(Usage,LabelID)

AsphaltPaintedStencil(paintColor,Usage,LabelID)-->
	# Stencils should have no reporting, managed by overlay shapes.
	alignScopeToAxes(y)
	alignScopeToGeometry(yUp,largest,longest)
	extrude(world.up,sharrowHeight)
	normalizeUV(0,uv, separatePerFace)
	setupProjection(0,scope.xz,Asphalt_Tile_Size,Asphalt_Tile_Size,Asphalt_Tile_Size,Asphalt_Tile_Size,1)
	texture(LanesFolder+"/Asphalt003_2K_" + paintColor + "_Color.jpg")
	set(material.name,str(material.name)+"_"+str(paintColor))
	projectUV(0)
	ProjectPBRTextures(LanesFolder+"/"+Asphalt_Base,Usage,LabelID,false)
	
ReportManager(Usage,LabelID,Report)-->
	case Report:
		ColorAndReport(Usage,LabelID)
	else:
		color( _ThematicRouter (Usage,LabelID))#If Display Thematics==Usage, goes to usage, if not, Thematic. 
		Delete_Texture

ColorAndReport(Usage,LabelID)-->
	color( _ThematicRouter (Usage,LabelID))#If Display Thematics==Usage, goes to usage, if not, Thematic. 
	ModeReporter(Usage)
	Delete_Texture

ModeReporter(Usage)-->
	case reportingOn:
		report("Mode Area (m^2)."+str(Usage),geometry.area)
	else:
		NIL
		
NoGeometryModeReporter(Usage)-->
	case reportingOn:
		report("Mode Area (m^2)."+str(Usage),geometry.area)
		NIL
	else:
		NIL

# ------------------Paint:-------------------------
#######################################################################
#Vehicles
# 
# Sample assets provided by Esri CityEngine Team
# 
# -------------------------------------------

vehicleAsset(type) = fileRandom( CompleteStreetFolder + "/Low_Poly_Esri_CityEngine_Vehicles/" + type + "/*.glb")

const vehiclesProb = ( Vehicles_Per_KM *minCarDistance)/1000
const busProb	   = (Bus_Lane_Buses_Per_KM*minCarDistance)/1000
const minCarDistance = 6

BusOnLane(dir)-->
	case geometry.du(0,unitSpace)>10:
		split(u,unitSpace,0){ ~1: BusOnLane(dir) | (rand(15,25)): Bus_Vehicle(dir,"bus") }
	else:
		NIL

MixedTrafficOnLane (dir,lanenumber,lanestotal) -->
	case geometry.du(0,unitSpace) > 1000:
		split(u,unitSpace,0){ '0.5: MixedTrafficOnLane (dir,lanenumber,lanestotal) | '0.5: MixedTrafficOnLane (dir,lanenumber,lanestotal) }
	case geometry.du(0,unitSpace) > 10 && p( Mixed_Traffic_Bus_Percentage):
		split(u,unitSpace,0){ ~1: MixedTrafficOnLane (dir,lanenumber,lanestotal) | (rand(15,25)): Vehicle(dir,"bus") }
	case geometry.du(0,unitSpace) > 10 && p( Mixed_Traffic_Freight_Percentage):
		split(u,unitSpace,0){ ~1: MixedTrafficOnLane (dir,lanenumber,lanestotal) | (rand(15,25)): Vehicle(dir,"freight") }
	case geometry.du(0,unitSpace) > 5 && p(Mixed_Traffic_Bike_Percentage)&& lanenumber==0: #Allocate only on Curb Lanes
		split(u,unitSpace,0){ ~1: MixedTrafficOnLane (dir,lanenumber,lanestotal) | (rand(minCarDistance,8)): Bike(dir,Lane_Width,1) }
	case geometry.du(0,unitSpace) > 5:
		split(u,unitSpace,0){ ~1: MixedTrafficOnLane (dir,lanenumber,lanestotal) | (rand(minCarDistance,15)): VehicleTaxiOrCar(dir) }
	else:
		NIL

VehicleTaxiOrCar(dir) -->
	case p(Taxi_Percentage): 
		Vehicle(dir,"taxi") 
	else:
		Vehicle(dir,"car") 

Bus_Vehicle(dir,type) --> 
	case p(busProb):
		split(u,unitSpace,0){ ~1: NIL | 0.5: alignScopeToGeometry(yUp,0,dir) VehicleAsset(type) | ~1: NIL }
	else:
		NIL	

Vehicle(dir,type) --> 
	case p(vehiclesProb):
		split(u,unitSpace,0){ ~1: NIL | 0.5: alignScopeToGeometry(yUp,0,dir) VehicleAsset(type) | ~1: NIL }
	else:
		NIL	
		
VehicleAsset(type) -->
	t(0,0,'rand(0.4,0.6)) 
	s(0,0,0) 
	r(0,-90,0)
	r(0,DirectionalRotation,0) 
	i(vehicleAsset(type))
	label(type)
	set(material.name,str(type))
	color( _ThematicRouter (case type=="bus":"Transit" else:"Auto",case type=="bus":"bus"else:"car"))
	Delete_Texture


# -------------------------------------------
# Cyclists
# 
# Sample assets provided by lowpolygon3d.com
# 
# More assets with high-res textures can be 
# purchased at http://www.lowpolygon3d.com.
# 
# -------------------------------------------

bikeAsset = fileRandom( CompleteStreetFolder + "/LowPolygon3D.com_Cyclists/*.obj")

const bikeProb = (Bicycles_Per_KM * minBikeDistance)/1000
const minBikeDistance = 2

Bikes(dir,Bike_Lane_Width,bike_probability) -->
	case bike_probability > 0:
		BikesOnLane(dir,Bike_Lane_Width)		
	else:
		NIL
	
BikesOnLane(dir,Bike_Lane_Width) --> #Fix: Lots of logic here that doesn't apply to bikes, since it was adapted from car logic.
case geometry.du(0,unitSpace) > 1000:
	split(u,unitSpace,0){ '0.5: BikesOnLane(dir,Bike_Lane_Width) | '0.5: BikesOnLane(dir,Bike_Lane_Width) }
case geometry.du(0,unitSpace) > 5:
	split(u,unitSpace,0){ ~1: BikesOnLane(dir,Bike_Lane_Width) | (rand(minBikeDistance,3)): Bike(dir,Bike_Lane_Width,bikeProb) }
else:
	NIL

	
Bike(dir,Bike_Lane_Width,bike_probability) --> 
	case p(bike_probability):
		split(u,unitSpace,0){ ~1: NIL | 0.5: alignScopeToGeometry(yUp,0,dir) BikeAsset(Bike_Lane_Width) | ~1: NIL }
	else:
		NIL	
		
BikeAsset(Bike_Lane_Width) -->
	rotateScope(0,DirectionalRotation,0) 
	t(0,0,Bike_Lane_Width/2 + rand(-Bike_Lane_Width/4,Bike_Lane_Width/4)) 
	s(0,0,0) 
	r(scopeCenter,0,90,0)
	i(bikeAsset) 
	label("bicyclist")
	set(material.name,"Bicyclist")
	Delete_Color_Texture("Bikeways","bicyclist")
	
Delete_Color_Texture(Mode,label)-->
	case thematicsOn && !texturingOn:
		deleteUV(0)
		color( _ThematicRouter (Mode,label))
	case thematicsOn:
		color( _ThematicRouter (Mode,label))
	case !texturingOn:
		deleteUV(0)		
	else:
		X.

Delete_Texture-->
	case texturingOn: 
		X.	
# 		print(geometry.isInstanced())	
	else: 
		deleteUV(0)
# 		print(geometry.isInstanced())

# -------------------------------------------
# People
# 
# Sample assets provided by lowpolygon3d.com
# 
# More assets with high-res textures can be 
# purchased at http://www.lowpolygon3d.com.
# 
# -------------------------------------------

peopleAsset = fileRandom( CompleteStreetFolder + "/LowPolygon3D.com_People/*.obj")
dirHuman = 50%: 90 else: -90

People -->
	case geometry.du(0,unitSpace) > 20:
		split(u,unitSpace,0){ '0.5: People | '0.5: People }
	case People_Percentage > 0:
		50% : split(u,unitSpace,0){ { 0.1: Human | ~rand(2,5): NIL | 0.1: Human | ~rand(2,5): NIL }* | 0.1: Human }          # could be distributed better...
		else: split(u,unitSpace,0){ { 0.1: Human | ~rand(0.5,5.5): NIL | 0.1: Human | ~rand(0.5,5.5): NIL }* | 0.1: Human }  # could be distributed better...
	else:
		NIL
	
Human -->
	case (scope.sz < 2 && p(People_Percentage*0.3)) 
			|| (scope.sz >= 2 && p(People_Percentage)):
		alignScopeToAxes(y)
		t(0,0,'rand(0.1,0.6))
		s(0,rand(1.7,1.9),0) r(0,dirHuman,0) 
		label("person")
		color( _ThematicRouter ("Pedestrian","pedestrian"))
		i(peopleAsset)
		set(material.name,"Person")
		Delete_Texture
	else:
		NIL

# Bridge can be explicitly activated or deactivated,
# or automatically set by height over terrain.

isBridge = (Bridge_Display == "On, Regardless")
	|| (Bridge_Display == "On, Show All Piers")
	|| (Bridge_Display == "On, By Elevation" && isRaised) 


# Road segment is raised if it is higher than Bridge_Starts_At attribute.
# isRaised DOES NOT imply it is a bridge.
isRaised = heightOverTerrain > Bridge_Starts_At

heightOverTerrain = convert(y, scope, world, pos, 
	 scope.sx * 0.5, scope.sy * 0.5, scope.sz * 0.5) - elevation
# The above convert function finds the y world coordinate at the center
# of the scope, then subtracts the elevation to get the 
# height over the terrain. 
# NOTE: To use this function, you must add a layer attribute
# to your terrain layer, like this:  
#   attr elevation = map_01(brightness, 405.20847, 419.22385) + elevationDelta

BridgeMain-->
	case isBridge:
		# For debugging:
		#print("heightOverTerrain = " + heightOverTerrain)
		# Give bridge thickness, sending the street shape to thickness rule. 
		BridgeConcrete(Bridge_Thickness)
		# Drop street shape down by thickness, to split for piers.
		translate(rel, world, 0, -Bridge_Thickness, 0)
		# Split to make starting points for piers.
		split(u, unitSpace, 0) {
			~( Pier_Distance / 2) :  NIL 
			| { Pier_Width : Pier | ~ Pier_Distance :  NIL }* 
			# XX: Not sure why the pattern was repeated in this manner:
			| Pier_Width : Pier |  ~ Pier_Distance :  NIL 
		}
	case Bridge_Display== "Concrete Extrusion Only":
		BridgeConcrete(Bridge_Thickness)
	case Bridge_Display=="Dimension Extrusion":
		#Depends on no changes to the start rules that call this one. 
		StreetDimensionMassing (initialShape.startRule,(case sidewalkSide=="Right":0 case sidewalkSide=="Left":2 else:1),Bridge_Thickness)
	else : 
		NIL

Pier -->
	case heightOverTerrain > 0:
		split(v,unitSpace,0){ '0.15: NIL
			| '0.70: PierStep2 
			| '0.15: NIL }
	else: NIL

PierStep2 -->
	alignScopeToGeometry(yUp,0,0)
	# Make "feeler" for occlusion check in next rule.
	# Extrude down to the terrain (must be mapped in layer attribute).
	extrude(world.y,-heightOverTerrain)
	# Align to yUp for feeler scaling.
	alignScopeToAxes(y)
	# Scale to go past regular pier shape.
	s('1,'20,'1)
	t(0,-0.5,0) 
	# Check if pier will hit something.
	PierCheck

PierCheck-->
	PierShow

PierShow -->
	# Scale back occlusion feelers, reversing the feeler code.
	s('1,'0.05,'1)
	t(0,0.5,0) 
	split(y){2.2: PierBase | ~1: PierShafts | 1: BridgeSolid }

# XX: Come back later and make smarter pier sizing code. 	
PierShafts -->
	case scope.sz > 7:
		split(x){ 0.5: NIL 
				| ~1 : split(z){ ~1: NIL | ~3: comp(f){side: BridgeSolid}  | ~4: NIL | ~3: comp(f){side: BridgeSolid} | ~1: NIL }
				| 0.5: NIL }
	else:
		split(x){ 0.5: NIL 
				| ~1 : split(z){ ~0.5: NIL | ~3: comp(f){side: BridgeSolid} | ~0.5: NIL }
				| 0.5: NIL }
		
# XX: Come back later and make smarter pier sizing code.
StreetDimensionMassing(Location,dir,height)-->
	translate(rel,world,0,-height,0)
	extrude(world.y,height)
	StreetDimensionBuilder(Location,dir,height)
	
StreetDimensionBuilder(Location,dir,height)-->
	case Location=="Street":
		comp(f){top: NIL 
		| right= DimensionStreet(dir,"Front")
		|left=DimensionStreet(dir,"Back")
		|bottom=BridgeMaterial("No Color")
		|front=BridgeMaterial("No Color")
		|back=BridgeMaterial("No Color")
		 }
	case Location=="Sidewalk" && dir==0:
		comp(f){top: NIL 
		| right= DimensionSidewalk(dir,"Front")
		|left= DimensionSidewalk(dir,"Back")
		|bottom=BridgeMaterial("No Color")
		|front=BridgeMaterial("No Color")
		|back=BridgeMaterial("No Color")
		 }
	case Location=="Sidewalk" && dir==2:
		comp(f){top: NIL 
		| right=DimensionSidewalk(dir,"Back")
		|left= DimensionSidewalk(dir,"Front")
		|bottom=BridgeMaterial("No Color")
		|front=BridgeMaterial("No Color")
		|back=BridgeMaterial("No Color")
		 }
	else:
		BridgeConcrete(height)	
		
		
DimensionSidewalk(dir,segment_side)-->
	case Sidewalk_Ground_Cover =="None":
		setupProjection(0, scope.xy, '1, '1)
		projectUV(0)
		scaleUV(0,case segment_side=="Back":-1 else:1,1)
		scaleUV(0,case dir==2:-1 else:1,1)
		split(u,unitSpace,0) {_Side_Sidewalk_Furniture_Zone_Width(case dir==0: "Right" else: "Left")+Curb_Depth+
				_Side_Sidewalk_Planting_Width(case dir==0: "Right" else: "Left"):BridgeMaterial(NACTOPedestrian)# Uses a different loading section rule
				|_Sidewalk_BikeLane_Width(dir)	:BridgeMaterial(NACTOBike)
				|~1: BridgeMaterial(NACTOPedestrian)}
	else:
		setupProjection(0, scope.xy, '1, '1)
		projectUV(0)
		scaleUV(0,case segment_side=="Back":-1 else:1,1)
		scaleUV(0,case dir==2:-1 else:1,1)
		split(u,unitSpace,0) {(_Side_Sidewalk_Furniture_Zone_Width(case dir==0: "Right" else: "Left")
				+Curb_Depth+_Side_Sidewalk_Planting_Width(case dir==0: "Right" else: "Left")): BridgeMaterial(NACTOPlanting)
				|_Sidewalk_BikeLane_Width(dir)	: BridgeMaterial(NACTOBike)
				|~1: BridgeMaterial(NACTOPedestrian)}
		
DimensionStreet(dir,segment_side)-->
	setupProjection(0, scope.xy, '1, '1)
	projectUV(0)
	scaleUV(0,case segment_side=="Back":-1 else:1,1)	
	split(u,unitSpace,0){~1:BridgeMaterial(NACTOConflictZone)
			|(_RightSplitSum+ _Distribute_Right_Lanes* _Actual_Lane_Width+_Rt_Transit_Lane_Width):DimensionRightStreet(dir,segment_side)# Will flip with a change in driving direction
			| _centerWidth											  : DimensionCenterSection(dir,segment_side)# Will flip with a change in driving direction
			|(_LeftSplitSum+nLanesLeft*_Actual_Lane_Width+_Lt_Transit_Lane_Width)	  :DimensionLeftStreet(dir,segment_side)# Will flip with a change in driving direction
			|~1:BridgeMaterial(NACTOConflictZone)}
DimensionCenterSection(dir,segment_side)-->
	case Center_Type=="Boulevard":
		split(u,unitSpace,0) {~(case WalkWay_Width==0:1 else:WalkWay_Width):BridgeMaterial(NACTOConflictZone)
			|Boulevard_Inside_Width:DimensionCenter(dir,segment_side)
			|~(case WalkWay_Width==0:1 else:WalkWay_Width):BridgeMaterial(NACTOConflictZone)}
	else:
		BridgeMaterial(NACTOConflictZone)

DimensionCenter(dir,segment_side)-->
	split(u,unitSpace,0) {Boulevard_Inside_Width/2-(Boulevard_Center_Width/2):BridgeMaterial(Dimension_Center_Hexcode)
						|Boulevard_Center_Width:BridgeMaterial(NACTOConflictZone)
						|Boulevard_Inside_Width/2-(Boulevard_Center_Width/2): BridgeMaterial(Dimension_Center_Hexcode)}
			
DimensionRightStreet(dir,segment_side)-->
# Divides the two street sides into left subsection made up of splitspace (holds bike, parking, and buffer),repeater conventional lanes, and transit lanes (activiated by Location Switch).  
	split(u,unitSpace,0){(_Transit_Lane_Width_Switch(0,"Sidewalk Side")):BridgeMaterial(NACTOTransit)
						|_RightSplitSum:DimensionRightSplitSpace(dir,segment_side)
						|(_Transit_Lane_Width_Switch(0,"Right Most Lane")):BridgeMaterial(NACTOTransit)
						|( _Distribute_Right_Lanes* _Actual_Lane_Width):DimensionStreetLanes(dir,segment_side)
						|(_Transit_Lane_Width_Switch(0,"Left Most Lane")):BridgeMaterial(NACTOTransit)}
DimensionLeftStreet(dir,segment_side)-->
# Divides the two street sides into left subsection made up of splitspace (holds bike, parking, and buffer),repeater conventional lanes, and transit lanes (activiated by Location Switch).  
	split(u,unitSpace,0){(_Transit_Lane_Width_Switch(2,"Left Most Lane")): scaleUV(0,-1,-1) BridgeMaterial(NACTOTransit)
						|(nLanesLeft*_Actual_Lane_Width ):  translateUV(0,0,-geometry.vMax) scaleUV(0,-1,-1)    # mirror the uv coords
					  			DimensionStreetLanes(dir,segment_side)
					  	|(_Transit_Lane_Width_Switch(2,"Right Most Lane")):scaleUV(0,-1,-1) BridgeMaterial(NACTOTransit)
					  	|_LeftSplitSum:DimensionLeftSplitSpace(dir,segment_side)
					  	|(_Transit_Lane_Width_Switch(2,"Sidewalk Side")):scaleUV(0,-1,-1) BridgeMaterial(NACTOTransit)}	  
DimensionStreetLanes(dir,segment_side)-->
	split(u,unitSpace,0){{~_Actual_Lane_Width : BridgeMaterial(NACTOAuto)}*}	

DimensionRightSplitSpace(dir,segment_side)-->
	scaleUV(0,case Parking_Protection_Bool :-1 else:1,1)
	split(u,unitSpace,0){Right_Parking_Width :BridgeMaterial(NACTOStorage)
						|( Street_Right_Bike_Lane_Width + Right_Buffer_Width ):DimensionRightBikeLaneSpace(dir,segment_side)}
						
DimensionLeftSplitSpace(dir,segment_side)-->
	scaleUV(0,case Parking_Protection_Bool :-1 else:1,1)
	split(u,unitSpace,0){( Street_Left_Bike_Lane_Width + Left_Buffer_Width ):DimensionLeftBikeLaneSpace(dir,segment_side)
							| Left_Parking_Width :BridgeMaterial(NACTOStorage)}

DimensionLeftBikeLaneSpace(dir,segment_side)-->
	scaleUV(0,case Buffer_Protection_Bool : -1 else:1,1)
	scaleUV(0,case Parking_Protection_Bool :-1 else:1,1)
	split(u,unitSpace,0) { Street_Left_Bike_Lane_Width :BridgeMaterial(NACTOBike)
						  |Left_Buffer_Width :BridgeMaterial(NACTOBikeDark)}
	
DimensionRightBikeLaneSpace(dir,segment_side)-->
	scaleUV(0,case Buffer_Protection_Bool : -1 else:1,1)
	scaleUV(0,case Parking_Protection_Bool :-1 else:1,1)
	split(u,unitSpace,0) {Right_Buffer_Width :BridgeMaterial(NACTOBikeDark)
						  |Street_Right_Bike_Lane_Width :BridgeMaterial(NACTOBike)}						

#BikeLane Start
PierBase -->
	s('1,scope.sy+5,'1) t(0,-5.3,0) i("builtin:cube")
	comp(f){ side: BridgeSolid | top: roofHip(60) split(y){ 0.3: BridgeSolid } }

BridgeSide-->
	case isBridge:
		BridgeRailing
		BridgeConcrete(0.4) translate(rel,world,0,-0.4,0)
		reverseNormals 
		comp(f){all: BridgeSlope }
	case Bridge_Display== "Concrete Extrusion Only":
		BridgeConcrete(Bridge_Thickness)
	case Bridge_Display=="Dimension Extrusion":
		StreetDimensionMassing (initialShape.startRule,(case sidewalkSide=="Right":0 case sidewalkSide=="Left":2 else:1),Bridge_Thickness)
	else: NIL

BridgeCrossing -->
	case isBridge:
		BridgeConcrete(Bridge_Thickness)
	else: NIL

BridgeSlope -->
	case geometry.isRectangular(10) && Bridge_Thickness > 2:
		roofShed(23,2)
		comp(f){all = BridgeMaterial("No Color") }
	else:
		NIL

BridgeConcrete(height) -->
	translate(rel,world,0,-height,0)
	extrude(world.y,height)
	comp(f){top: NIL | all= BridgeMaterial("No Color") }

BridgeRailing -->
	case Not_Low_LOD:
		translate(rel,world,0, Sidewalk_Height ,0)
		split(v,unitSpace,0){ ~1: NIL | 0.4: 
			extrude(world.y,0.8) 
			color(case coloringOn: "#eeeeee" else: "") 
			comp(f){all: BridgeMaterial("No Color")} }
		split(v,unitSpace,0){ ~1: NIL | 0.1: 
			translate(rel,world,0,0.8,0) 
			VerticalRails 
			translate(rel,world,0,0.3,0) 
			extrude(world.y,0.05) 
			RailMaterial 
			| 0.17: NIL }
	else:
		translate(rel,world,0, Sidewalk_Height ,0)
		split(v,unitSpace,0){ ~1: NIL | 0.4: extrude(world.y,0.8) color(case coloringOn: "#eeeeee" else: "") comp(f){all: BridgeMaterial("No Color") } }
		split(v,unitSpace,0){ ~1: NIL | 0.1: translate(rel,world,0,0.8,0) VerticalRails translate(rel,world,0,0.3,0) comp(f){ all: extrude(world.y,0.05) comp(f){front: RailMaterial} | 0.17: NIL } }

VerticalRails -->
	case Not_Low_LOD:
		comp(f){all: split(x){ ~1 : NIL 
							 | 0.1: s('1,0.07,'1) center(y) extrude(world.y,0.3) RailMaterial
							 | { ~2 : NIL 
							 |   0.1: s('1,0.07,'1) center(y) extrude(world.y,0.3) RailMaterial }*
							 | ~1 : NIL } }
	else:
		comp(f){all: split(x){ ~1 : NIL 
							 | 0.1: s('1,0.07,'1) center(y) extrude(world.y,0.3) comp(f){front: RailMaterial}
							 | { ~2 : NIL 
							 |   0.1: s('1,0.07,'1) center(y) extrude(world.y,0.3) comp(f){front: RailMaterial} }*
							 | ~1 : NIL } }		

BridgeSolid -->
      comp(f){ all: setupProjection(2,scope.xy,'1,'1) projectUV(2)
		set(material.dirtmap,LanesFolder+"/dirtmap.1.512x512.jpg")
        BridgeMaterial("No Color") }

BridgeMaterial(color_chooser) --> #Ground Textured Rule
	case find(str(color_chooser),"#",0)!=-1:
		color(color_chooser)
		setupProjection(0,scope.xy,~12,~9,0,0,0) projectUV(0)
		texture(Default_Pavement)
		Delete_Texture
	else:
		setupProjection(0,scope.xy,~12,~9) projectUV(0)
		texture(Default_Pavement)
		Delete_Texture
	
	
RailMaterial --> #Ground Textured Rule
	case texturingOn:
		set(material.specular.r, 1) set(material.specular.g, 1) set(material.specular.b, 1)
		set(material.shininess, 20)
		setupProjection(0,scope.xy,~12,~9,0,0,1) projectUV(0)
		texture(SidewalkFolder+"/Concrete Rough Light.jpg")
		RailMaterialStep2
	else:		
		RailMaterialStep2

RailMaterialStep2 -->
	case coloringOn:
		color("#cccccc")
	else:
		X.
	
###################################################
# Misc
#
Pervious_Reporting-->
	case peakRunoffDisplayOn:
		set(material.name,"Planting_Area")
		report("Vegetation.Pervious Area",geometry.area)
		color(0,0,1)
		Delete_Texture
		
	else:
		set(material.name,"Planting_Area")
		report("Vegetation.Pervious Area",geometry.area)
		color( _ThematicRouter ("Plantings","planting_area"))#If Display Thematics==Usage, goes to usage, if not, Thematic.
		Delete_Texture

Cut_And_Fill_Reporting(Text_Fill)-->
	report("Cut/Fill.Total "+Text_Fill+" Cut/Fill Volume (m^3)", geometry.area()*Sidewalk_Height)
	NIL


Rumble_Strip--> #Ground Textured Rule
	tileUV(0,~Rumble_Strip_Len,~Rumble_Strip_Wid)
	rotateUV(0,90)
	texture(LanesFolder+"/Rumble_Strip.jpg")
	ColorAndReport("Auto","asphalt")
	
Drainage--> #Ground Textured Rule
	case geometry.dv(0,unitSpace)> Lane_Width /3 && Space_Management=="Flag":#Will flag the drainage area as Red if it is >1/3 the laneWidth-I mean really 1/3 of a lane is drainage? Put a bike lane or something
		AsphaltPainted("red","Conflict Zones","asphalt")
		color(.7,0,0)	 	
	else:
		Asphalt("Conflict Zones","asphalt") 
		
Enclose_Shape-->
	set(material.opacity,0)#Make it transparent
	X. #Enclose
	
#Fence Rule 

Fence(Location)-->
	split(v,unitSpace,0) {~1:NIL|
						 .05:FenceMesh
						 |~1:NIL}
	FencePoles

FenceMesh -->
	extrude(world.y,1.3)
	alignScopeToAxes(y) #Cast Scope to prevent edge issues 
	alignScopeToGeometry(yUp, 0, 3)#Cast Scope to prevent edge issues. 
	FencePrep

FencePrep-->
	comp(f) {left=FenceTexture|all:NIL}
	
FenceTexture -->
	case Boulevard_Center_Type=="Chain Link Fence":
	setupProjection(0, scope.xy, ~1.2, '1)
	projectUV(0)
	texture(MiscFolder+"/Fence/wireTexture.png")
	Delete_Texture
	case Boulevard_Center_Type=="Gate Fence":
	setupProjection(0, scope.xy, ~4, '1)
	projectUV(0)
	texture(MiscFolder+"/Fence/aluminumPerimeter.png")
	Delete_Texture
	else:
	setupProjection(0, scope.xy, ~1.2, ~1)
	projectUV(0)
	texture(MiscFolder+"/Fence/wireTexture.png")
	Delete_Texture

FencePoles -->
	case  Boulevard_Center_Type=="Chain Link Fence":
		split(u,unitSpace,0) {{0.01: PoleBase | ~ 3.5: NIL }* | 0.01: PoleBase}
	else:
		NIL
poleDim = 0.04

PoleBase -->
	alignScopeToAxes(y)
	s(poleDim, 0, poleDim)
	center(xz)
	i(MiscFolder+"/Fence/quad.obj")
	center(xz)
	extrude(world.y, 1.3)
	comp(f) {all: PoleTexturing}

PoleTexturing -->
	setupProjection(0, scope.xy, 1, 1)
	projectUV(0)
	texture(MiscFolder+"/Fence/aluLight.png")
	
#Debugging Rules	
#White-->
	#envelope(world.up, .1016, .05, 50, .05, 50,.05,60)
	#alignScopeToAxes(y)
	#t(0,1,0)
	#color(1,1,1)	
# Red-->
# 	alignScopeToAxes(y)
# 	t(0,1,0)
# 	color(1,0,0)
# Blue-->
# 	alignScopeToAxes(y)
# 	t(0,1,0)
# 	color(0,0,1)
##				
